use std::collections::HashMap;

use parser::syntax::{expr::Expr, variable::Variable, fndecl::FnDecl};

use crate::program::Program;

#[derive(PartialEq, Debug, Clone)]
pub enum Value<'a> {
    Str(String),
    Int(isize),
    Float(f64),

    Function(FnDecl<'a>, &'a Expr<'a>),
    None,
}

pub struct Interpreter<'a> {
    program: &'a mut Program,
}

pub struct Frame<'a> {
    parent: Option<&'a Frame<'a>>,
    root: &'a Interpreter<'a>,
    variables: HashMap<&'a str, Value<'a>>,
}

impl<'a> Interpreter<'a> {
    pub fn interpret(&mut self) {
        let (remnant, _expr) = Expr::parse(&self.program.source).unwrap();
        self.program.source = remnant.to_string();
    }
}
impl<'a> Frame<'a> {
    fn new(parent: Option<&'a Frame<'a>>, root: &'a Interpreter<'a>) -> Self {
        Frame { parent, variables: HashMap::new(), root }
    }
    pub fn eval(&mut self, expr: &Expr) -> Value {
        match expr {
            Expr::Call(call) => {
                let mut args_names: Vec<&str> = vec![];
                {
                let func = self.eval(&call.function);
                match func {
                    Value::Function(decl, _body) => {
                        if decl.args.len() != call.args.len() {
                            panic!("Trying to call {:?} with {} args (it accepts {})", call, call.args.len(), decl.args.len());
                        }
                        for i in decl.args {
                            let vname = Frame::variable_name(i.variable.clone());
                            args_names.push(vname);
                        }

                    },
                    _ => panic!("Cannot call a {:?}", func),
                }
                }
                let mut variables: HashMap<&str, Value> = HashMap::new();
                let mut vals: Vec<Value> = vec![];
                for i in &call.args {
                    vals.push(self.eval(i));
                }
                // for (pos, name) in args_names.iter().enumerate() {
                //     variables.insert(name, self.eval(&call.args[pos]));
                // }
                todo!()

                // let (fndecl, body) = self.root.variables.get()
                // for i in call.args {
                //     
                // }
                // todo!()
            },
            Expr::Atom(atom) => {
                match atom {
                    parser::syntax::atom::Atom::Assign(assign) => { todo!() },
                    parser::syntax::atom::Atom::VarDef(_) => todo!(),
                    parser::syntax::atom::Atom::FnDecl(_) => todo!(),
                    parser::syntax::atom::Atom::Variable(v) => self.eval_variable(v),
                    parser::syntax::atom::Atom::Block(block) => { // got this is horrible
                        let mut vec = block.exprs.clone();
                        let last = match vec.pop() {
                            Some(s) => s,
                            None => return Value::None,
                        };
                        for i in vec {
                            self.eval(&i);
                        }
                        self.eval(&last)
                    },
                    parser::syntax::atom::Atom::Literal(literal) => {
                        match literal {
                            parser::syntax::literal::Literal::Str(s) => Value::Str(s.clone()),
                            parser::syntax::literal::Literal::Int(i) => Value::Int(*i),
                            parser::syntax::literal::Literal::Float(f) => Value::Float(*f),
                        }
                    },
                }
            },
        }
    }
    fn eval_variable(&self, var: &Variable) -> Value {
        match var {
            Variable::Reference(_) => todo!(),
            Variable::Dereference(_) => todo!(),
            Variable::Identifier(i) => self.variables.get(i.name).unwrap().clone(),
        }
    }
    fn variable_name(var: Variable) -> &str {
        match var {
            Variable::Reference(_) => todo!(),
            Variable::Dereference(_) => todo!(),
            Variable::Identifier(i) => i.name,
        }
    }
}
