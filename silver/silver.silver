// EXTERNS {{{

func malloc(bytes: u64) : &u8;
func realloc(data: &u8, bytes: u64) : &u8;
func strlen(str: &u8) : u64;
prefix free(data: &u8);
func strcpy(dest: &u8, src: &u8);
func strncpy(dest: &u8, src: &u8, len: u64);
func memcpy(dest: &u8, src: &u8, len: u64);
func strcmp(a: &u8, b: &u8) : u64;
func printf(str: &u8);
/* func printf(str: &u8, val: u64); */
/* func printf(str: &u8) = printf(str, 0); */
func putchar(char: u8);
func exit(code: u64);
func pow(base: u64, power: u64): u64;

// little extern thing to help me debug
// cuz i cant be asked to write it here
// func print_addr(addr: &u8);

// }}}


// SYSTEM {{{

#prec 25;
infix ==(a: u64, b: u64) : bool = @AS("int_cmp_eq a b");

#prec 25;
infix !=(a: u64, b: u64) : bool = @AS("int_cmp_neq a b");

#prec 30;
infix <(a: u64, b: u64) : bool = @AS("int_cmp_ult a b");

#prec 30;
infix >(a: u64, b: u64) : bool = @AS("int_cmp_ugt a b");

#prec 30;
infix <=(a: u64, b: u64) : bool = @AS("int_cmp_ule a b");

#prec 30;
infix >=(a: u64, b: u64) : bool = @AS("int_cmp_uge a b");

#prec 20;
infix &&(a: u64, b: u64) : u64 = @AS("int_and a b");

#prec 20;
infix ||(a: u64, b: u64) : u64 = @AS("int_or a b");

#prec 25;
infix ==(a: u8, b: u8) : bool = @AS("int_cmp_eq a b");

#prec 25;
infix !=(a: u8, b: u8) : bool = @AS("int_cmp_neq a b");

#prec 30;
infix <(a: u8, b: u8) : bool = @AS("int_cmp_ult a b");

#prec 30;
infix >(a: u8, b: u8) : bool = @AS("int_cmp_ugt a b");

#prec 30;
infix <=(a: u8, b: u8) : bool = @AS("int_cmp_ule a b");

#prec 30;
infix >=(a: u8, b: u8) : bool = @AS("int_cmp_uge a b");

#prec 20;
infix &&(a: u8, b: u8) : u8 = @AS("int_and a b");

#prec 20;
infix ||(a: u8, b: u8) : u8 = @AS("int_or a b");

#prec 20;
infix &&(a: bool, b: bool) : bool = @AS("bool_and a b");

#prec 20;
infix ||(a: bool, b: bool) : bool = @AS("bool_or a b");

#prec 20;
infix %(a: u64, b: u64) : u64 = @AS("int_signed_mod a b");


#prec 10;
macro infix =(a: _, b: _) = @AS("store_in a b");

#prec 10;
macro infix [=](a: _, b: _) = @AS("raw_store_in a b");

prefix !(a: bool) : bool = @AS("bool_not a");

#prec 75;
infix +(a: u64, b: u64) : u64 = @AS("int_add a b");

#prec 75;
infix -(a: u64, b: u64) : u64 = @AS("int_sub a b");

#prec 100;
infix *(a: u64, b: u64) : u64 = @AS("int_mul a b");

macro suffix ++(a: _) : _ = {
    a = a + 1;
    a
};

macro suffix --(a: _) : _ = {
    a = a - 1;
    a
};

#prec 10;
macro infix +=(a: _, b: _) : _ = {
    a = a + b;
    a
};

/* prec 10; */
/* macro infix -=(a: _, b: _) : _ = { */
/*     a = a - b; */
/*     a */
/* }; */
/**/
/* prec 10; */
/* macro infix *=(a: _, b: _) : _ = { */
/*     a = a * b; */
/*     a */
/* }; */

// TODO: fix this ugly mess
#prec 120;
infix ^(a: u64, b: u64) : u64 = {
  if b == 0 { 1 }
  else {
    total: u64 = a;
    while (b - 1) > 0 {
      total = total * a;
      b = b - 1;
    };
    total
  }
};

func assert(val: bool, message: &u8) = if !val {
        printf("Assertion failed: ");
        printf(message);
        printf("\n");
        exit(1)
    };

func assertVerbose(val: bool, message: &u8) = if val {
        printf("Assertion succeeded: ");
        printf(message);
        printf("\n");
    } else {
        printf("Assertion failed: ");
        printf(message);
        printf("\n");
        exit(1);
    };

overloadable func panic(message: &u8) = {
    printf("Panic!\n");
    printf(message);
    exit(1);
};

overloadable func panic() = {
    printf("Panic!\n");
    exit(1);
};

func debugPrint(message: &u8) = {
    printf(message);    
};
// }}}

func printint(i: u64);

// STRING {{{

brackets [ ](str: &u8, index: u64) : &u8 = @AS("single_gep str index");

#prec 15;
infix ==(a: &u8, b: &u8) : bool = strcmp(a, b) == 0;

#prec 15;
infix !=(a: &u8, b: &u8) : bool = strcmp(a, b) != 0;

prefix copy(str: &u8) : &u8 = {
    dupl: &u8;
    dupl = malloc(str.strlen() + 1);
    strcpy(dupl, str);

    // bad debug tiem
    /* printf("Copied `"); */
    /* printf(dupl); */
    /* printf("` to `"); */
    /* print_addr(dupl); */
    /* printf("`\n"); */
    dupl
};

/* func length(str: &u8) : u64 = strlen(str); */

func contains(str: &u8, char: u8) : bool = {
    // TODO: revert to old logic after signage is fixed
    length: u64 = str.strlen();
    index: u64 = 0;
    while index != length {
        if *(str[index]) == char {
            return true 
        };
        index++;
    };
    false
};

func isNumeric(char: u8) : bool = (char >= '0') && (char <= '9');

func isAlpha(char: u8) : bool = ((char >= 'A') && (char <= 'Z') || (char >= 'a') && (char <= 'z'));

func isAlphanumeric(char: u8) : bool = char.isNumeric() || char.isAlpha();

func isWhitespace(char: u8) : bool = " \t\n".contains(char);

func printRepeatedChar(char: u8, repeat: u64) = {
    while repeat != 0 {
        putchar(' ');
        repeat--;
    };
};

func printIndentation(indentation: u64) = {
    putchar('\n');
    printRepeatedChar(' ', indentation);
};

// }}}


// LEXER {{{

// type str = &u8;

type Lexer = {
    input: &u8,
    index: u64,
    input_len: u64,
};

// input is not copied
func lexer#new(input: &u8) : Lexer = {
    lexer: Lexer;
    (&lexer).index = 0;
    (&lexer).input = input;
    (&lexer).input_len = (&lexer).input.strlen();
    lexer
};

func peek(lexer: &Lexer) : Lexer = {
    dupl: Lexer;
    &dupl.input = lexer.input;
    &dupl.index = lexer.index;
    (&dupl).input_len = lexer.input_len;
    dupl
};

func peekChar(lexer: &Lexer) : u8 = {
    if lexer.index >= lexer.input_len {
        return '\0';    
    };
    *((lexer.input)[lexer.index])
};

func takeChar(lexer: &Lexer) : u8 = {
    a: u8 = lexer.peekChar();
    lexer.index = lexer.index + 1;
    a
};

func isEof(lexer: &Lexer) : bool = lexer.index >= lexer.input_len;

type LexString = {
    parent: &Lexer,
    offset: u64,
    len: u64
};

#prec 75;
infix + (a: LexString, b: LexString) : LexString = {
    result: LexString;
    if ((&a).offset + (&a).len) != (&b).offset {
        /* printf("%lu neq ", (&a).offset); */
        /* printf("%lu\n", (&a).len); */
        /* printf("%lu\n", (&b).offset); */
        panic("Trying to add two non-contiguous LexStrings");
    };
    (&result).offset = (&a).offset;
    (&result).len = (&a).len + (&b).len;
    (&result).parent = (&a).parent;

    result
};

func lexstring#new(parent: &Lexer, start: u64, end: u64) : LexString = {
    lexstring: LexString;
    (&lexstring).parent = parent;
    (&lexstring).offset = start;
    (&lexstring).len = (end - start);

    lexstring
};

// BIG TODO: implment lambdas for more monadic operation

// must remember to free!
// also, might segfault
// TODO: bounds-check logic
func render(lexstring: &LexString) : &u8 = {
    str: &u8;
    str = malloc(lexstring.len + 1);
    strncpy(str, (lexstring.parent.input)[lexstring.offset], lexstring.len);
    str[lexstring.len] [=] '\0';
    str
};

func debugLexString(val: &LexString, indentation: u64) = {
    str: &u8 = val.render();
    printIndentation(indentation);
    printf(str);
    free str;
};

func takeNumber(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    first_dot: bool = true;
    // TODO: this specific logic feels stupid. surely there's a better way?
    while lexer.peekChar().isNumeric() || ((lexer.peekChar() == '.') && first_dot) {
        (&string.len)++;
        if lexer.takeChar() == '.' first_dot = false;
    };
    string
};

func isConventionalId(char: u8, first: bool) : bool = char.isAlpha() || (char.isNumeric() && !first) || (char == '_');

func isSpecialId(char: u8) : bool = "+-><*/=%!&.[]|".contains(char);

func takeIdentifier(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    first: bool = true;
    while lexer.peekChar().isConventionalId(first) {
        /* printf("LTAKE\n"); */
        (&string.len)++;
        if first { first = false; };
        lexer.takeChar();
    };

    if &string.len == 0 {
        while lexer.peekChar().isSpecialId() {
          /* printf("LTAKES\n"); */
            (&string.len)++;
            lexer.takeChar();
        };
    };

    string
};

func takeOnlyWhitespace(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    while lexer.peekChar().isWhitespace() {
        (&string.len)++;
        lexer.takeChar();
    };

    string
};

func takeComment(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;

    if lexer.peekChar() == '/' {
        peeked_: Lexer = lexer.peek();
        peeked: &Lexer = &peeked_;
        peeked.takeChar();
        c: u8 = peeked.peekChar();
        if c == '/' {
            lexer.takeChar();
            lexer.takeChar();

            (&string.len) += 2;

            while lexer.takeChar() != '\n' {
                (&string.len)++;
            };
        } else if c == '*' {
            lexer.takeChar();
            lexer.takeChar();

            (&string.len) += 2;

            while true {
                if lexer.takeChar() == '*' {
                    if lexer.peekChar() == '/' {
                            lexer.takeChar();
                            (&string.len) += 2;
                            break;
                    };
                };
                (&string.len)++;
            };
        };
    };

    string
};

func takeWhitespace(lexer: &Lexer) : LexString = {
    string: LexString = lexer.takeOnlyWhitespace();
    while lexer.peekChar() == '/' {
        string += lexer.takeComment();
        string += lexer.takeOnlyWhitespace();
    };

    string
};

overloadable func require(lexer: &Lexer, char: u8) : LexString = {
    lexer.takeWhitespace();
    
    string: LexString;
    (&string).offset = lexer.index;
    (&string).parent = lexer;
    (&string.len) = 1;

    if lexer.takeChar() != char {
        printf("Expected `");
        putchar(char);
        printf("` but got `");
        putchar(char);
        printf("`\n");
        panic("invalid character");
    };
    string
};

overloadable func require(lexer: &Lexer, str: &u8) : LexString = {
    lexer.takeWhitespace();
    
    string: LexString = lexer.takeIdentifier();

    if (&string).render() != str {
        printf("Expected str `");
        printf(str);
        printf("` but got `");
        printf((&string).render());
        printf("`\n");
        panic("invalid character");
    };
    string
};

// }}}


// LIST {{{

<T> type VariableArray = {
    len: u64,
    set_size: u64,
    data: &T
};

/* <T> func shallow_copy(va: <T> VariableArray) : & <T> VariableArray = { */
/*     new: & <T> VariableArray = malloc(@sizeof(<T> VariableArray)); */
/*     memcpy(new as &u8, (&va) as &u8, @sizeof(<T> VariableArray)); */

/*     new */
/* }; */

<T> func variablearray#new() : <T> VariableArray = {
    va: <T> VariableArray;
    
    (&va).data = malloc(@sizeof(T) * 64) as &T;
    (&va).len = 0;
    (&va).set_size = @sizeof(T) * 64;

    va
};

<T> func get(va: & <T> VariableArray, index: u64) : &T = {
    data: &T = va.data;
    @AS("single_gep data index") as &T
};

<T> func set(va: & <T> VariableArray, index: u64, val: T) = {
    memcpy(((va.get<T>(index)) as &u8), (&val) as &u8, @sizeof(T));
};

<T> func append(va: & <T> VariableArray, val: T) = {
    va.len += 1;
    if (va.len * @sizeof(T)) > va.set_size {
        va.set_size += (@sizeof(T) * 64);
        va.data = (realloc((va.data) as &u8, va.set_size) as &T);
    };
    /* (*(va.get<T>(va.len - 1))) = val; */
    va.set<T>(va.len - 1, val);
};

<T> prefix drop(va: <T> VariableArray) = {

    free((&va).data);
};
// }}}

// BIG TODO: BOXES

// PARSER {{{

type Parser = {
    lexer: &Lexer
};

enum ExprType = {
    Number,
    Identifier,
    Block,
    String,
    If,
    While,
    /* Brackets, */
};

type Expr = {
    value: &u8, // something something data pointer
    variant: ExprType
};

type NumberExpr = {
    source: LexString,
    parsed: u64,
};

type IdentifierExpr = {
    source: LexString,
    // TODO: namespaces
};

type BlockExpr = {
    source: LexString,
    exprs: <Expr> VariableArray,
    use_last_val: bool,
};

type StringExpr = {
    source: LexString,
    value: &u8,
};

type IfExpr = {
    source: LexString,
    cond: Expr,
    then: Expr,
    has_else: bool,
    else: Expr,
};

type WhileExpr = {
    source: LexString,
    cond: Expr,
    then: Expr,
};

// Type parsing {{{
enum TypeType {
    Reference,
    Named,
    Struct,
    Func,
};

type TypeExpr {
    variant: TypeType,
    value: &u8,
};

type NamedTypeExpr {
    name: LexString,
};

func debugTypeExpr(ty: &TypeExpr) = {
  /* printIndentation(indentation); */
    if ty.variant == TypeType#Reference {
        printf("& ");
        debugTypeExprInternal(ty.value as &TypeExpr);
    } else if ty.variant == TypeType#Named {
        rendered: &u8 = (&((ty.value as &NamedTypeExpr).name)).render();
        printf(rendered);
        free rendered;
    } else {
        printf("Dunno how to debug this type type")
      }
};

// TODO: all the rest of the types; lambdas; templates

/* type StructTypeExpr { */
    /*  */
/* }; */
//  }}}


// lexer is moved
func parser#new(lexer: &Lexer) : Parser = {
    parser: Parser;
    (&parser).lexer = lexer;
    parser
};

overloadable func debugExprType(val: &ExprType, indentation: u64) = {
    printIndentation(indentation);
    if *val == ExprType#Number {
        printf("ExprType#Number");
    } else if *val == ExprType#Identifier {
        printf("ExprType#Identifier");
    } else if *val == ExprType#Block {
        printf("ExprType#Block");
    } else if *val == ExprType#String {
        printf("ExprType#String");
    } else if *val == ExprType#If {
        printf("ExprType#If");
    } else if *val == ExprType#While {
        printf("ExprType#While");
    } else {
        printf("Debug expr type for this one not implmented yet");
    }
};


// forward-def
func parseExpr(parser: &Parser) : Expr;
// GOT HERE, need to forward-def overloadbles
func debugBlockExpr(val: &BlockExpr, indentation: u64);
func debugIdentifierExpr(val: &IdentifierExpr, indentation: u64);
func debugNumberExpr(val: &NumberExpr, indentation: u64);
func debugStringExpr(val: &StringExpr, indentation: u64);
func debugIfExpr(val: &IfExpr, indentation: u64);
func debugWhileExpr(val: &WhileExpr, indentation: u64);

overloadable func debugExpr(val: &Expr, indentation: u64) = {
    debugExprType(&(val.variant), indentation);
    if val.variant == ExprType#Block {
        debugBlockExpr((val.value) as &BlockExpr, indentation);
    } else if val.variant == ExprType#Identifier {
        debugIdentifierExpr((val.value) as &IdentifierExpr, indentation);
    } else if val.variant == ExprType#Number {
        debugNumberExpr((val.value) as &NumberExpr, indentation);
    } else if val.variant == ExprType#String {
        debugStringExpr((val.value) as &StringExpr, indentation);
    } else if val.variant == ExprType#If {
        debugIfExpr((val.value) as &IfExpr, indentation);
    } else if val.variant == ExprType#While {
        debugWhileExpr((val.value) as &WhileExpr, indentation);
    } else {
        printf("Dunno how to debug this type");
    }
};

prefix drop(expr: Expr) = {
    free (&expr.value);
};


func debugNumberExpr(val: &NumberExpr, indentation: u64) = {
    debugLexString(&(val.source), indentation);
};

func parseNumberExpr(parser: &Parser) : NumberExpr = {
    debugPrint("Parsing number\n");
    number: LexString = parser.lexer.takeNumber();
    if &number.len == 0 {
        panic("Expected number");
    };
    expr: NumberExpr;
    &expr.source = number;

    // TODO: atoi

    expr
};

prefix copy(val: NumberExpr) : &NumberExpr = {
    data: &NumberExpr = malloc(@sizeof(NumberExpr)) as &NumberExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(NumberExpr));

    data
};

overloadable func asExpr(number: NumberExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Number;

    // TODO: make it more silvery
    &expr.value = (copy number) as &u8;

    expr
};


func debugIdentifierExpr(val: &IdentifierExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("`");
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    printf("`");
    // debugLexString(&(val.source), indentation);
};

func parseIdentifierExpr(parser: &Parser) : IdentifierExpr = {
    debugPrint("Parsing identifier expr\n");
    id: LexString = parser.lexer.takeIdentifier();
    if &id.len == 0 {
        panic("Expected valid identifier");
    };
    expr: IdentifierExpr;
    &expr.source = id;

    expr
};

prefix copy(val: IdentifierExpr) : &IdentifierExpr = {
    data: &IdentifierExpr = malloc(@sizeof(IdentifierExpr)) as &IdentifierExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(IdentifierExpr));

    data
};

overloadable func asExpr(id: IdentifierExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Identifier;

    &expr.value = (copy id) as &u8;

    expr
};
func debugBlockExpr(val: &BlockExpr, indentation: u64) = {
    printIndentation(indentation);
    exprs: <Expr> VariableArray;
    exprs = val.exprs;
    // printint((&exprs).len);

    printf("Block: {");
    i: u64 = 0;
    while i < (&exprs).len {
        debugExpr(((&(val.exprs)).get<Expr>(i)), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("} using last value: ");
    printf(
        if val.use_last_val {
          "true"
        } else { "false" }
    );
    // printIndentation(indentation);
    // printf("}");
};

func parseBlockExpr(parser: &Parser) : BlockExpr = {
    debugPrint("Parsing block expr\n");
    parser.lexer.takeWhitespace();

    start: u64 = parser.lexer.index;
    
    parser.lexer.require('{');
    expr: BlockExpr;
    exprs: <Expr> VariableArray = variablearray#new<Expr>();

    last_semicolon: bool = true;

    while !(parser.lexer.isEof()) && (parser.lexer.peekChar() != '}') {
        internal_expr: Expr = parser.parseExpr();
        printf("parsing ex\n");
        debugExprType(&((&internal_expr).variant), 0);
        (&exprs).append<Expr>(internal_expr);
        // printint((&exprs).len);
        /* if (&exprs).len == 1 {panic("This does not math");}; */
        // GOT HERE
        // debugExprType(&((&exprs).get<Expr>(1).variant), 0);
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() == '}' {
            debugPrint("Broke loop\n");
            debugPrint("got: ");
            last_semicolon = false;
            break;
        };
        parser.lexer.require(';');
        parser.lexer.takeWhitespace();
    };

    parser.lexer.require('}');
    printf("len: ");
    printint((&exprs).len);

    end: u64 = parser.lexer.index;

    (&expr).exprs = exprs;
    (&expr).source = lexstring#new(parser.lexer, start, end);
    (&expr).use_last_val = !last_semicolon;

    expr
};

prefix copy(val: BlockExpr) : &BlockExpr = {
    data: &BlockExpr = malloc(@sizeof(BlockExpr)) as &BlockExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(BlockExpr));

    data
};

overloadable func asExpr(id: BlockExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#Block;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugStringExpr(val: &StringExpr, indentation: u64) = {
    printIndentation(indentation);
    /* printf("`"); */
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseStringExpr(parser: &Parser) : StringExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('"');

    str: <u8> VariableArray = variablearray#new<u8>();
    escaped: bool = false;
    while true {
        next_char: u8 = parser.lexer.takeChar();
        if escaped {
            (&str).append<u8>(next_char);
        } else {
            if next_char == '\\' {
                escaped = true;
            } else if next_char == '"' {
                break;
            } else {
                (&str).append<u8>(next_char);
            }
        }
    };

    end: u64 = parser.lexer.index;
    s: StringExpr;
    (&s).source = lexstring#new(parser.lexer, start, end);
    (&s).value = (&str).data;

    s
};

prefix copy(val: StringExpr) : &StringExpr = {
    data: &StringExpr = malloc(@sizeof(StringExpr)) as &StringExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(StringExpr));

    data
};

overloadable func asExpr(id: StringExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#String;

    (&expr).value = (copy id) as &u8;

    expr
};

<T> func flatCopy(val: T) : &T = {
    data: &T = malloc(@sizeof(T)) as &T;
    memcpy(data as &u8, (&val) as &u8, @sizeof(T));

    data
};

func debugIfExpr(val: &IfExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("IF: ");
    debugExpr(&(val.cond), indentation + 2);
    printIndentation(indentation);
    printf("THEN: ");
    debugExpr(&(val.then), indentation + 2);
    if (val.has_else) {
      printIndentation(indentation);
      printf("ELSE: ");
      debugExpr(&(val.else), indentation + 2);
    };
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseIfExpr(parser: &Parser) : IfExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("if");
    
    cond: Expr = parseExpr(parser);
    then: Expr = parseExpr(parser);
    parser.lexer.takeWhitespace();

    else: Expr;
    peek_: Lexer = parser.lexer.peek();
    peeked: &Lexer = &peek_;
    n_id: LexString = peeked.takeIdentifier();
    next: &u8 = (&n_id).render();
    has_else: bool = if next == "else" {
        parser.lexer.takeIdentifier();
        else = parser.parseExpr();
        true
    } else false;

    free next;

    end: u64 = parser.lexer.index;
    i: IfExpr;
    (&i).source = lexstring#new(parser.lexer, start, end);
    (&i).cond = cond;
    (&i).then = then;
    (&i).else = else;
    (&i).has_else = has_else;

    i
};

prefix copy(val: IfExpr) : &IfExpr = flatCopy<IfExpr>(val);

overloadable func asExpr(id: IfExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#If;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugWhileExpr(val: &WhileExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("WHILE: ");
    debugExpr(&(val.cond), indentation + 2);
    printIndentation(indentation);
    printf("DO: ");
    debugExpr(&(val.then), indentation + 2);
};

func parseWhileExpr(parser: &Parser) : WhileExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("while");
    
    cond: Expr = parseExpr(parser);
    then: Expr = parseExpr(parser);

    end: u64 = parser.lexer.index;
    w: WhileExpr;
    (&w).source = lexstring#new(parser.lexer, start, end);
    (&w).cond = cond;
    (&w).then = then;
    w
};

prefix copy(val: WhileExpr) : &WhileExpr = flatCopy<WhileExpr>(val);

overloadable func asExpr(id: WhileExpr) : Expr = {
  expr: Expr;
  (&expr).variant = ExprType#While;
  (&expr).value = (copy id) as &u8;

  expr
};

func parseExpr(parser: &Parser) : Expr = {
    debugPrint("Parsing expr");
    parser.lexer.takeWhitespace();

    next_char: u8 = parser.lexer.peekChar();
    /* printf("Peeked char: `"); */
    putchar(next_char);
    /* printf("`\n"); */
    if next_char.isNumeric() {
        parser.parseNumberExpr().asExpr()
    } else if (next_char.isConventionalId(true) || next_char.isSpecialId()) {
        peeked_: Lexer = (parser.lexer.peek());
        peeked: &Lexer = &peeked_;
        nextTok: LexString = peeked.takeIdentifier();
        next: &u8 = (&nextTok).render();
        e: Expr = if next == "if" {parser.parseIfExpr().asExpr()}
        else if next == "while" {parser.parseWhileExpr().asExpr()}
        else {parser.parseIdentifierExpr().asExpr()};
        free next;
        e
    } else if next_char == '{' {
        ba: BlockExpr = parser.parseBlockExpr();
        e: Expr = ba.asExpr();
        e
    } else if next_char == '"' {
      parser.parseStringExpr().asExpr()
    } else {
        expr: Expr;
        printf("Cannot parse: `");
        putchar(next_char);
        printf("`\n");
        panic();

        expr
    }
};


// }}}

// HASHMAP {{{
<K, V> type HMLinkedListElem = {
    hash: u64,
    val: &V,
    has_next_elem: bool,
    next_elem: &u8,// <T>HMLinkedListElem, // or 0 if no next elem, forgive me for using nullptrs
};

<K, V> prefix drop(elem: & <K, V>HMLinkedListElem) = {
    free(elem.val);
    if (elem.next_elem) as u64 != 0 {
        drop(elem.next_elem);
    };
    free(elem as &u8);
};

/* <T> type HMBucket = { */
/*     hash_offset: u8, */
/*     does_contain_sub_buckets: bool, */
/*     // array of length uhh 16 */
/*     sub_buckets: &&HMBucket, */
/*     // else, a linked list of values of max length uhh 8? */
/*     sub_values: <T> HMLinkedListElem, */
/*     sub_values_len: u8, */
/*     is_using_linked_list: bool, */
/* }; */

/* <T> func hmbucket#new(hash_offset: u8): <T> HMBucket = { */
/*     bucket: <T> HMBucket; */
/*     bucket.hash_offset = hash_offset; */
/*     bucket.sub_values_len = 0; */
/*     // TODO */
/*     bucket */
/* }; */

<K, V> overloadable func hmlist_contains_internal(self: & <K, V> HMLinkedListElem, hash: u64) : bool = {
  current: &<K, V>HMLinkedListElem = self;
  while true {
    /* printf("checking\n"); */
    if (current.hash) == hash { return true }
    else if !(current.has_next_elem) { return false }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem)}
  };
  false
};
<K, V> overloadable func hmlist_contains(self: & <K, V> HMLinkedListElem, key: K) : bool = self.hmlist_contains_internal(hash(key));

<K, V> overloadable func hmlist_get(self: & <K, V> HMLinkedListElem, key: K) : &V = {
  hash: u64 = hash(key);
  current: & <K, V>HMLinkedListElem = self;
  while true {
    /* printf("get checking\n"); */
    if (current.hash) == hash { return (current.val) }
    else if ! (current.has_next_elem) { panic("Getting an element that doesn't exist") }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem) }
  };
  self.val
};

<K, V> overloadable func hmlist_get_elem_internal(self: & <K, V> HMLinkedListElem, hash: u64) : & <K, V> HMLinkedListElem = {
  current: &<K, V>HMLinkedListElem = self;
  while true {
    /* printf("getelem checking\n"); */
    if (current.hash) == hash { return current }
    else if !(current.has_next_elem) { panic("Getting an element that doesn't exist") }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem) }
  };
  self
};

<K, V> overloadable func hmlist_add(self: & <K, V> HMLinkedListElem, key: K, value: V) = {
  hash: u64 = hash(key);
  if self.hmlist_contains_internal<K, V>(hash) {
    elem: & <K, V>HMLinkedListElem = self.hmlist_get_elem_internal<K, V>(hash);
    elem.val = (malloc(@sizeof(V)) as &V);
    memcpy((elem.val) as &u8, (&value) as &u8, @sizeof(V));
  } else {
    elem: <K, V>HMLinkedListElem;
    (&elem).hash = hash;
    (&elem).val = (malloc(@sizeof(V)) as &V);
    memcpy((&(elem).val) as &u8, (&value) as &u8, @sizeof(V));
    &(elem).has_next_elem = (self.has_next_elem);
    &(elem).next_elem = (self.next_elem);
    elem2: & <K, V>HMLinkedListElem = malloc(@sizeof(elem)) as & <K, V>HMLinkedListElem;
    memcpy(elem2 as &u8, (&elem) as &u8, @sizeof(elem));
    (self.next_elem) = elem2 as &u8;
    (self.has_next_elem) = true;
  }
};

<K, V> func hmlist#new(key: K, value: V): <K, V> HMLinkedListElem = {
  elem: <K, V>HMLinkedListElem;
  &(elem).hash = hash(key);
  &(elem).val = (malloc(@sizeof(V)) as &V);
  memcpy((&(elem).val) as &u8, (&value) as &u8, @sizeof(V));
  &(elem).has_next_elem = false;
  elem
};


<K, V> overloadable func add(self: & <K, V>HMBucket, value: V, hash: u64) = {
  if self.is_using_linked_list {
    hnelem: bool = true;
    elem: <K, V> HMLinkedListElem = *(self.sub_values);
    while hnelem {
      if *(elem.hash) == hash {
        elem.val = value;
      };
      hnelem = *(elem.has_next_elem);
      elem = *(elem.next_elem);
    };
  };
};

<T> type HashMap = {
    buckets: &&HMBucket,
};

<T> prefix drop(elem: & <T> HMBucket) = {
    if elem.does_contain_sub_buckets {
        i: u8 = 0_8;
        while i != 16 {
            /* drop<T> elem.sub_buckets[i]; */
        };
    } else {
        /* drop<T> elem.sub_values; */
    };
    free(elem as &u8);
};
// }}}

// HASHINGS {{{
overloadable func hash(h: u64): u64 = h;
overloadable func hash(h: &u8): u64 = {
  i: u64 = 0;
  total: u64 = 0;
  while ((*h[i])) != 0_8 {
    q: u8 = *h[i];
    /* putchar(q); */
    /* putchar(':'); */
    /* printint(2^2); */
    p: u64 = @AS("int_z_extend q 64");
    total += (53^i) * p;
    i += 1;
  };
  total = (total % 1000000009);
  /* printf("Hash of "); */
  /* printf(h); */
  /* printint(total); */
  total
};
// }}}

// MAIN {{{

func main() : u64 = {
    code: &u8 = "{if {a; b; c} while c b else f}";
    lexer: &Lexer = &lexer#new(code);
    parser: &Parser = &parser#new(lexer);
    e: Expr = parser.parseExpr();
    (&e).debugExpr(0);
    /* printf("main"); */
    /* data: &u8 = malloc(9223372036854775807 * @sizeof(u64)); */
    /* (*data[0]) = 7_8; */
    /* printf("begin\n"); */
    /* code: &u8 = "178.7492 aa 786 bcd"; */
    /* lexer: &Lexer = &lexer#new(code); */
    /**/
    /*  */
    /* string: &LexString = & &(lexer.takeWhitespace()); */
    /* printf(string.render()); */
    /**/
    /* putchar('\n'); */

    /* string: &LexString = & &(lexer.takeNumber()); */
    /* printf(string.render()); */
    /**/
    /* putchar('\n'); */
    /**/
    /* lexer.takeWhitespace(); */
    /**/
    /* string = & &(lexer.takeIdentifier()); */
    /* printf(string.render()); */
    /* putchar('\n'); */
    /**/
    /* parser: &Parser = &parser#new(lexer); */
    /**/
    /* parser.parseNumberExpr(); */
    /* parser.parseNumberExpr(); */

    /* va: <&u8> VariableArray; */
    /* va = variablearray#new<&u8>(); */

    /* (&va).append<&u8>("he"); */

    /* printf(*((&va).get<&u8>(0))); */

    /* va: <u64> VariableArray; */
    /* va = variablearray#new<u64>(); */

    /* (&va).append<u64>(7); */

    /* if *((&va).get<u64>(0)) == 7 { */
    /*     printf("yay\n"); */
    /* }; */
    /* if *((&va).get<u64>(0)) == 0 { */
    /*     printf("noo\n"); */
    /* }; */

    /* if (&va).len == 1 { */
    /*     printf("correct length\n"); */
    /* }; */
    /* va: <&u8> VariableArray; */
    /* va = variablearray#new<&u8>(); */
    /* (&va).append<&u8>("hello\n"); */
    /* s: &&u8 = (&va).get<&u8>(0); */
    /* printf(*s); */

    /* source: &u8 = "{\"babc\"}"; */

    /* lexer: &Lexer = &lexer#new(source); */
    /* parser: &Parser = &parser#new(lexer); */

    /* printf("hello"); */

    /* expr: Expr = parser.parseExpr(); */

    /* printf("here lol\n"); */

    /* printf("Input was:\n"); */
    /* printf(source); */

    /* printf("\nOutput was:\n"); */

    /* debugExpr(&expr, 0); */
    /* printf("here20"); */
    /* q: <&u8, &u8> HMLinkedListElem = hmlist#new<&u8, &u8>("k1", "jhelp"); */
    /* printf("here"); */
    /* (&q).hmlist_add<&u8, &u8>("k2", "aaaa"); */
    /* p: &&u8 = (&q).hmlist_get<&u8, &u8>(4); */
    /* printf(*p); */
    /* p: &&u8 = (&q).hmlist_get<&u8, &u8>("k1"); */
    /* printf(*p); */

    exit(0);
    0
};


// }}}10
