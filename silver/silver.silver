// EXTERNS {{{
func malloc(bytes: u64) : &u8;
func realloc(data: &u8, bytes: u64) : &u8;
func strlen(str: &u8) : u64;
prefix free(data: &u8);
func strcpy(dest: &u8, src: &u8);
func strncpy(dest: &u8, src: &u8, len: u64);
func memcpy(dest: &u8, src: &u8, len: u64);
func strcmp(a: &u8, b: &u8) : u64;
func printf(str: &u8);
/* func printf(str: &u8, val: u64); */
/* func printf(str: &u8) = printf(str, 0); */
func putchar(char: u8);
func exit(code: u64);
func pow(base: u64, power: u64): u64;
func printint(i: u64);

// little extern thing to help me debug
// cuz i cant be asked to write it here
// func print_addr(addr: &u8);

// }}}

// SYSTEM {{{

#prec 25, builtin IntCmpEQ;
infix ==(a: u64, b: u64) : bool = @AS("int_cmp_eq a b");

#prec 25, builtin IntCmpNE;
infix !=(a: u64, b: u64) : bool = @AS("int_cmp_neq a b");

#prec 30, builtin IntCmpULT;
infix <(a: u64, b: u64) : bool = @AS("int_cmp_ult a b");

#prec 30, builtin IntCmpUGT;
infix >(a: u64, b: u64) : bool = @AS("int_cmp_ugt a b");

#prec 30, builtin IntCmpULE;
infix <=(a: u64, b: u64) : bool = @AS("int_cmp_ule a b");

#prec 30, builtin IntCmpUGE;
infix >=(a: u64, b: u64) : bool = @AS("int_cmp_uge a b");

#prec 20, builtin And;
infix &&(a: u64, b: u64) : u64 = @AS("int_and a b");

#prec 20, builtin Or;
infix ||(a: u64, b: u64) : u64 = @AS("int_or a b");

#prec 25, builtin IntCmpEQ;
infix ==(a: u8, b: u8) : bool = @AS("int_cmp_eq a b");

#prec 25, builtin IntCmpNEQ;
infix !=(a: u8, b: u8) : bool = @AS("int_cmp_neq a b");

#prec 30, builtin IntCm;
infix <(a: u8, b: u8) : bool = @AS("int_cmp_ult a b");

#prec 30;
infix >(a: u8, b: u8) : bool = @AS("int_cmp_ugt a b");

#prec 30;
infix <=(a: u8, b: u8) : bool = @AS("int_cmp_ule a b");

#prec 30;
infix >=(a: u8, b: u8) : bool = @AS("int_cmp_uge a b");

#prec 20;
infix &&(a: u8, b: u8) : u8 = @AS("int_and a b");

#prec 20;
infix ||(a: u8, b: u8) : u8 = @AS("int_or a b");

#prec 20;
infix &&(a: bool, b: bool) : bool = @AS("bool_and a b");

#prec 20;
infix ||(a: bool, b: bool) : bool = @AS("bool_or a b");

#prec 20;
infix %(a: u64, b: u64) : u64 = @AS("int_signed_mod a b");


#prec 10;
macro infix =(a: _, b: _) = @AS("store_in a b");

#prec 10;
macro infix [=](a: _, b: _) = @AS("raw_store_in a b");

prefix !(a: bool) : bool = @AS("bool_not a");

#prec 75;
infix +(a: u64, b: u64) : u64 = @AS("int_add a b");

#prec 75;
infix -(a: u64, b: u64) : u64 = @AS("int_sub a b");


#prec 75;
infix -(a: u8, b: u8) : u8 = @AS("int_sub a b");

#prec 100;
infix *(a: u64, b: u64) : u64 = @AS("int_mul a b");

macro suffix ++(a: _) : _ = {
    a = a + 1;
    a
};

macro suffix --(a: _) : _ = {
    a = a - 1;
    a
};

#prec 10;
macro infix +=(a: _, b: _) : _ = {
    a = a + b;
    a
};

/* prec 10; */
/* macro infix -=(a: _, b: _) : _ = { */
/*     a = a - b; */
/*     a */
/* }; */
/**/
/* prec 10; */
/* macro infix *=(a: _, b: _) : _ = { */
/*     a = a * b; */
/*     a */
/* }; */

// TODO: fix this ugly mess
#prec 120;
infix ^(a: u64, b: u64) : u64 = {
  if b == 0 { 1 }
  else {
    total: u64 = a;
    while (b - 1) > 0 {
      total = total * a;
      b = b - 1;
    };
    total
  }
};

func assert(val: bool, message: &u8) = if !val {
        printf("Assertion failed: ");
        printf(message);
        printf("\n");
        exit(1)
};

func assertVerbose(val: bool, message: &u8) = if val {
        printf("Assertion succeeded: ");
        printf(message);
        printf("\n");
    } else {
        printf("Assertion failed: ");
        printf(message);
        printf("\n");
        exit(1);
    };

overloadable func panic(message: &u8) = {
    printf("Panic!\n");
    printf(message);
    exit(1);
};

overloadable func panic() = {
    printf("Panic!\n");
    exit(1);
};

func debugPrint(message: &u8) = {
    printf(message);    
};


<T> func flatCopy(val: T) : &T = {
    data: &T = malloc(@sizeof(T)) as &T;
    memcpy(data as &u8, (&val) as &u8, @sizeof(T));

    data
};
// }}}


// STRING {{{

brackets [ ](str: &u8, index: u64) : &u8 = @AS("single_gep str index");

#prec 15;
infix ==(a: &u8, b: &u8) : bool = strcmp(a, b) == 0;

#prec 15;
infix !=(a: &u8, b: &u8) : bool = strcmp(a, b) != 0;

prefix copy(str: &u8) : &u8 = {
    dupl: &u8;
    dupl = malloc(str.strlen() + 1);
    strcpy(dupl, str);

    // bad debug tiem
    /* printf("Copied `"); */
    /* printf(dupl); */
    /* printf("` to `"); */
    /* print_addr(dupl); */
    /* printf("`\n"); */
    dupl
};

/* func length(str: &u8) : u64 = strlen(str); */

func contains(str: &u8, char: u8) : bool = {
    // TODO: revert to old logic after signage is fixed
    length: u64 = str.strlen();
    index: u64 = 0;
    while index != length {
        if *(str[index]) == char {
            return true 
        };
        index++;
    };
    false
};

func isNumeric(char: u8) : bool = (char >= '0') && (char <= '9');

func isAlpha(char: u8) : bool = ((char >= 'A') && (char <= 'Z') || (char >= 'a') && (char <= 'z'));

func isAlphanumeric(char: u8) : bool = char.isNumeric() || char.isAlpha();

func isWhitespace(char: u8) : bool = " \t\n".contains(char);

func printRepeatedChar(char: u8, repeat: u64) = {
    while repeat != 0 {
        putchar(' ');
        repeat--;
    };
};

func printIndentation(indentation: u64) = {
    putchar('\n');
    printRepeatedChar(' ', indentation);
};

func cToI(a: u8) : u64 = {
    q: u8 = a - '0';
    @AS("int_z_extend q 64")
};


func aToI(a: &u8) : u64 = {
    len: u64 = a.strlen();
    len = len;
    i: u64 = 0;
    ret: u64 = 0;
    while len > 0 {
        tmp: u64 = cToI(*(a[len - 1]));
        j: u64 = 0;
        while j < i {
            tmp = tmp * 10;
            j++;
        };
        i++;
        len--;
        ret += tmp;
    };

    ret
};



// }}}


// HASHMAP {{{
<K, V> type HMLinkedListElem = {
    hash: u64,
    key: K,
    val: &V,
    has_next_elem: bool,
    next_elem: &u8,// <T>HMLinkedListElem, // or 0 if no next elem, forgive me for using nullptrs
};

<K, V> prefix drop(elem: & <K, V>HMLinkedListElem) = {
    free(elem.val);
    if (elem.next_elem) as u64 != 0 {
        drop(elem.next_elem);
    };
    free(elem as &u8);
};


<K, V> overloadable func hmlist_contains_internal(self: & <K, V> HMLinkedListElem, hash: u64) : bool = {
  current: &<K, V>HMLinkedListElem = self;
  while true {
    /* printf("checking\n"); */
    if (current.hash) == hash { return true }
    else if !(current.has_next_elem) { return false }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem)}
  };
  false
};
<K, V> overloadable func hmlist_contains(self: & <K, V> HMLinkedListElem, key: K) : bool = self.hmlist_contains_internal<K, V>(hash(key));

<K, V> overloadable func hmlist_get(self: & <K, V> HMLinkedListElem, key: K) : &V = {
  hash: u64 = hash(key);
  current: & <K, V>HMLinkedListElem = self;
  while true {
    /* printf("get checking\n"); */
    if (current.hash) == hash { return (current.val) }
    else if ! (current.has_next_elem) { panic("Getting an element that doesn't exist") }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem) }
  };
  self.val
};

<K, V> overloadable func hmlist_get_elem_internal(self: & <K, V> HMLinkedListElem, hash: u64) : & <K, V> HMLinkedListElem = {
  current: &<K, V>HMLinkedListElem = self;
  while true {
    /* printf("getelem checking\n"); */
    if (current.hash) == hash { return current }
    else if !(current.has_next_elem) { panic("Getting an element that doesn't exist") }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem) }
  };
  self
};

<K, V> overloadable func hmlist_add(self: & <K, V> HMLinkedListElem, key: K, value: V) : &V = {
  hash: u64 = hash(key);
  if self.hmlist_contains_internal<K, V>(hash) {
    elem: & <K, V>HMLinkedListElem = self.hmlist_get_elem_internal<K, V>(hash);
    // TODO: free((elem.val) as &u8);
    elem.val = (malloc(@sizeof(V)) as &V);
    memcpy((elem.val) as &u8, (&value) as &u8, @sizeof(V));
    elem.val
  } else {
    elem: <K, V>HMLinkedListElem;
    (&elem).hash = hash;
    (&elem).val = (malloc(@sizeof(V)) as &V);
    (&elem).key = key;
    memcpy((&(elem).val) as &u8, (&value) as &u8, @sizeof(V));
    &(elem).has_next_elem = (self.has_next_elem);
    &(elem).next_elem = (self.next_elem);
    elem2: & <K, V>HMLinkedListElem = malloc(@sizeof(elem)) as & <K, V>HMLinkedListElem;
    memcpy(elem2 as &u8, (&elem) as &u8, @sizeof(elem));
    (self.next_elem) = elem2 as &u8;
    (self.has_next_elem) = true;
    elem2.val
  }
};

<K, V> func hmlist#new(key: K, value: V): <K, V> HMLinkedListElem = {
  elem: <K, V>HMLinkedListElem;
  &(elem).hash = hash(key);
  &(elem).key = key;
  &(elem).val = (malloc(@sizeof(V)) as &V);
  memcpy((&(elem).val) as &u8, (&value) as &u8, @sizeof(V));
  &(elem).has_next_elem = false;
  elem
};


<K, V> type HashMap = {
    has_init: bool,
    value: <K, V> HMLinkedListElem,
};

<K,V> func hashmap#new() : <K, V> HashMap = {
    h: <K, V>HashMap;
    (&h).has_init = false;
    h
};

<K, V> overloadable func hm_add(self: &<K, V>HashMap, key: K, value: V) : &V = {
    if self.has_init {
      (&(self.value)).hmlist_add<K, V>(key, value)
    } else {
      self.value = hmlist#new<K, V>(key, value);
      self.has_init = true;
      (&(self.value)).val
    }
};

<K, V> overloadable func hm_contains(self: &<K, V>HashMap, key: K) : bool = {
    if !(self.has_init) {false}
    else {
      (&(self.value)).hmlist_contains<K, V>(key)
    }
};

<K, V> overloadable func hm_get(self: &<K, V>HashMap, key: K) : &V = {
    if !(self.has_init) {panic("Getting an uninit HashMap"); v: V; &v}
    else {
        (&(self.value)).hmlist_get<K, V>(key)
    }
};

<K, V> overloadable func hm_vals(self: &<K, V>HashMap) : <&V> VariableArray = {
    v: <&V> VariableArray = variablearray#new<&V>();
    if self.has_init {
        val: &<K, V> HMLinkedListElem = &(self.value);
        (&v).append<&V>(val.val);
        while val.has_next_elem {
            val = (val.next_elem) as &<K, V> HMLinkedListElem;
            (&v).append<&V>(val.val);
        }
    };
    v
};

<K, V> overloadable func hm_keys(self: &<K, V>HashMap) : <K> VariableArray = {
    v: <K> VariableArray = variablearray#new<K>();
    if self.has_init {
        val: &<K, V> HMLinkedListElem = &(self.value);
        (&v).append<K>(val.key);
        while val.has_next_elem {
            val = (val.next_elem) as &<K, V> HMLinkedListElem;
            (&v).append<K>(val.key);
        }
    };
    v
};

// }}}

// HASHINGS {{{
overloadable func hash(h: u64): u64 = h;
overloadable func hash(h: &u8): u64 = {
  i: u64 = 0;
  total: u64 = 0;
  while ((*h[i])) != 0_8 {
    q: u8 = *h[i];
    /* putchar(q); */
    /* putchar(':'); */
    /* printint(2^2); */
    p: u64 = @AS("int_z_extend q 64");
    total += (53^i) * p;
    i += 1;
  };
  total = (total % 1000000009);
  /* printf("Hash of "); */
  /* printf(h); */
  /* printint(total); */
  total
};
// }}}


// LIST {{{

<T> type VariableArray = {
    len: u64,
    set_size: u64,
    data: &T
};

/* <T> func shallow_copy(va: <T> VariableArray) : & <T> VariableArray = { */
/*     new: & <T> VariableArray = malloc(@sizeof(<T> VariableArray)); */
/*     memcpy(new as &u8, (&va) as &u8, @sizeof(<T> VariableArray)); */

/*     new */
/* }; */

<T> func variablearray#new() : <T> VariableArray = {
    va: <T> VariableArray;
    
    (&va).data = malloc(@sizeof(T) * 64) as &T;
    (&va).len = 0;
    (&va).set_size = @sizeof(T) * 64;

    va
};

<T> func get(va: & <T> VariableArray, index: u64) : &T = {
    data: &T = va.data;
    @AS("single_gep data index") as &T
};

// brackets [ ] (va: &<T> VariableArray, i: u64) : &T = va.get<T

<T> func set(va: & <T> VariableArray, index: u64, val: T) = {
    memcpy(((va.get<T>(index)) as &u8), (&val) as &u8, @sizeof(T));
};

<T> func append(va: & <T> VariableArray, val: T) = {
    va.len += 1;
    if (va.len * @sizeof(T)) > va.set_size {
        va.set_size += (@sizeof(T) * 64);
        va.data = (realloc((va.data) as &u8, va.set_size) as &T);
    };
    /* (*(va.get<T>(va.len - 1))) = val; */
    va.set<T>(va.len - 1, val);
};

<T> prefix drop(va: <T> VariableArray) = {

    free((&va).data);
};

<T> func va_contains(va: & <T> VariableArray, val: T) : bool = {
    i: u64 = 0;
    while i < va.len {
        if *(va.get<T>(i)) == val {
            return true;
        };
        i++;
    };
    false
};


<T> func va_indexof(va: & <T> VariableArray, val: T) : u64 = {
    i: u64 = 0;
    while i < va.len {
        if *(va.get<T>(i)) == val {
            return i;
        };
        i++;
    };

    0
};

// I am the queen of bad code
// you can't have va == v2
<T> func append_va(va: & <T> VariableArray, v2: & <T> VariableArray) = {
  i: u64 = 0;
  while i < v2.len {
    va.append<T>(*(v2.get<T>(i)));
    i++;
  };
};

// }}}

// LIST AND STRING STUFF {{{
// yes I know this is ugly and godless
// and brings tears to my eyes
// but i am tired
// TODO: rewrite to use memcpy operations
// copies, doesn't move
func append_str(va: & <u8> VariableArray, str: &u8) = {
  i: u64 = 0;
  while (*(str[i])) != 0_8 {
    va.append<u8>(*(str[i]));
    i++;
  };
};


// this, too, is a bad idea.
// TODO: rewrite to either use strcpy or some sort of taking ownership and just saying "yup this is VA memory now"
// copies, doesn't move
func va_from_str(str: &u8) : <u8> VariableArray = {
  va: <u8> VariableArray = variablearray#new<u8>();
  (&va).append_str(str);
  va
};

// more crimes
func str_from_va(va: & <u8> VariableArray) : &u8 = {
  // must not forget nulltermi
  s: &u8 = malloc(@sizeof(u8) * (va.len + 1));
  strncpy(s, va.data, va.len);
  s[va.len] [=] 0_8;

  s
};

func itoa(val: u64, s: &u8) : &u8;

// itoa, base 10
func iToA_b10(i: u64) : &u8 = {
  // screw this stuff
  s: &u8 = malloc(@sizeof(u8) * 17);
  itoa(i, s)



  // todo: make this static/const/explicit or smth
  /*
  base: &u8 = "0123456789";
  // we could figure out how many digits we need with a log_10
  // but thats for nerds
  // va: <u8> VariableArray;
  if i == 0 {
    s: &u8 = malloc(@sizeof(u8) * 2);
    strcpy(s, "0");
    return s;
  };
  j: u64 = 0;
  while i != 0 {
    j = i % 10;
    (&va).append<u8>(*(base[j]));
    // sure I could integer division it
    // but i have trust issues ok
    i = i - j;
    i /= 10;
  };

  // this is equivalent to like
  // va.reversed.as_str
  // but we skip a few copies cuz my code sucks
  j = (&va).len;
  s: &u8 = malloc(j + 1);
  i = 0;
  // != instead of <= avoids some unsigned underflow shenanigans
  while j != 0 {
    s[i] [=] *((&va).get<u8>(j - 1));
    i++;
  };
  s[i] [=] 0_8;
  drop<u8>(va);
  
  s */
};
// }}}

// LEXER {{{

// type str = &u8;

type Lexer = {
    input: &u8,
    index: u64,
    input_len: u64,
};

// input is not copied
func lexer#new(input: &u8) : Lexer = {
    lexer: Lexer;
    (&lexer).index = 0;
    (&lexer).input = input;
    (&lexer).input_len = (&lexer).input.strlen();
    lexer
};

func peek(lexer: &Lexer) : Lexer = {
    dupl: Lexer;
    &dupl.input = lexer.input;
    &dupl.index = lexer.index;
    (&dupl).input_len = lexer.input_len;
    dupl
};

func peekChar(lexer: &Lexer) : u8 = {
    if lexer.index >= lexer.input_len {
        return '\0';    
    };
    *((lexer.input)[lexer.index])
};

func takeChar(lexer: &Lexer) : u8 = {
    a: u8 = lexer.peekChar();
    lexer.index = lexer.index + 1;
    a
};

func isEof(lexer: &Lexer) : bool = lexer.index >= lexer.input_len;

type LexString = {
    parent: &Lexer,
    offset: u64,
    len: u64
};

#prec 75;
infix + (a: LexString, b: LexString) : LexString = {
    result: LexString;
    (&result).offset = (&a).offset;
    (&result).len = (&b).len + (&b).offset - (&a).offset;
    (&result).parent = (&a).parent;

    result
};

func lexstring#new(parent: &Lexer, start: u64, end: u64) : LexString = {
    lexstring: LexString;
    (&lexstring).parent = parent;
    (&lexstring).offset = start;
    (&lexstring).len = (end - start);

    lexstring
};

// BIG TODO: implment lambdas for more monadic operation

// must remember to free!
// also, might segfault
// TODO: bounds-check logic
func render(lexstring: &LexString) : &u8 = {
    str: &u8;
    str = malloc(lexstring.len + 1);
    strncpy(str, (lexstring.parent.input)[lexstring.offset], lexstring.len);
    str[lexstring.len] [=] '\0';
    str
};

func debugLexString(val: &LexString, indentation: u64) = {
    str: &u8 = val.render();
    printIndentation(indentation);
    printf(str);
    free str;
};

func takeNumber(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    first_dot: bool = true;
    // TODO: this specific logic feels stupid. surely there's a better way?
    while lexer.peekChar().isNumeric() || ((lexer.peekChar() == '.') && first_dot) {
        (&string.len)++;
        if lexer.takeChar() == '.' first_dot = false;
    };
    string
};

func isConventionalId(char: u8, first: bool) : bool = char.isAlpha() || (char.isNumeric() && !first) || (char == '_') || (char == '@') || (char == '#');

func isSpecialId(char: u8) : bool = "+-><*/=%!&.|[]^".contains(char);
func isSingularId(char: u8) : bool = "()".contains(char);

func takeIdentifier(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    first: bool = true;
    while lexer.peekChar().isConventionalId(first) {
        /* printf("LTAKE\n"); */
        (&string.len)++;
        if first { first = false; };
        lexer.takeChar();
    };

    if &string.len == 0 {
        while lexer.peekChar().isSpecialId() {
          /* printf("LTAKES\n"); */
            (&string.len)++;
            lexer.takeChar();
        };
    };

    if &string.len == 0 {
        if lexer.peekChar().isSingularId() {
            (&string.len)++;
            lexer.takeChar();
        };
    };

    string
};

func takeOnlyWhitespace(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    while lexer.peekChar().isWhitespace() {
        (&string.len)++;
        lexer.takeChar();
    };

    string
};

func takeComment(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;

    if lexer.peekChar() == '/' {
        peeked_: Lexer = lexer.peek();
        peeked: &Lexer = &peeked_;
        peeked.takeChar();
        c: u8 = peeked.peekChar();
        if c == '/' {
            lexer.takeChar();
            lexer.takeChar();

            (&string.len) += 2;

            while lexer.takeChar() != '\n' {
                (&string.len)++;
            };
        } else if c == '*' {
            lexer.takeChar();
            lexer.takeChar();

            (&string.len) += 2;

            while true {
                if lexer.takeChar() == '*' {
                    if lexer.peekChar() == '/' {
                            lexer.takeChar();
                            (&string.len) += 2;
                            break;
                    };
                };
                (&string.len)++;
            };
        };
    };

    string
};

func takeWhitespace(lexer: &Lexer) : LexString = {
    string: LexString = lexer.takeOnlyWhitespace();
    while lexer.peekChar() == '/' {
        string += lexer.takeComment();
        string += lexer.takeOnlyWhitespace();
    };

    string
};

overloadable func require(lexer: &Lexer, char: u8) : LexString = {
    lexer.takeWhitespace();
    
    string: LexString;
    (&string).offset = lexer.index;
    (&string).parent = lexer;
    (&string.len) = 1;

    c: u8 = lexer.takeChar();

    if c != char {
        printf("Expected `");
        putchar(char);
        printf("` but got `");
        putchar(c);
        printf("`\n");
        panic("invalid character");
    };
    string
};

overloadable func require(lexer: &Lexer, str: &u8) : LexString = {
    lexer.takeWhitespace();
    
    string: LexString = lexer.takeIdentifier();

    if (&string).render() != str {
        printf("Expected str `");
        printf(str);
        printf("` but got `");
        printf((&string).render());
        printf("`\n");
        panic("invalid character");
    };
    string
};

// }}}

// PARSER {{{

type Parser = {
    lexer: &Lexer,
    // first then last then another set etc
    brackets: <u8> VariableArray,
    prefixes: <&u8> VariableArray,
    suffixes: <&u8> VariableArray,
    binaries: <&u8, u64> HMLinkedListElem,
};


// Type parsing {{{
enum TypeType = {
    Reference,
    Named,
    Struct,
    Func,
    Template,
};

type TypeExpr = {
    source: LexString,
    variant: TypeType,
    value: &u8,
};

type NamedTypeExpr = {
    name: LexString,
};

type TemplateTypeExpr = {
    types: <TypeExpr> VariableArray,
    value: TypeExpr,
};

// TODO: Default values
// TODO: calling things `type` really, _really_ shouldn't work
type StructVarDef = {
    name: LexString,
    type: TypeExpr,
};

type StructTypeExpr = {
    types: <StructVarDef> VariableArray,
};

func parseType(parser: &Parser) : TypeExpr;

func debugTypeExpr(ty: &TypeExpr, indentation: u64);

func debugStructVarDef(s: &StructVarDef, indentation: u64) = {
    printIndentation(indentation);
    debugLexString(&(s.name), indentation + 2);
    printIndentation(indentation);
    printf(":");
    debugTypeExpr(&(s.type), indentation + 2);
};
func debugStructTypeExpr(s: &StructTypeExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("STRUCT TYPE DEF:");
    i: u64 = 0;
    while i < (&(s.types)).len {
        debugStructVarDef((&(s.types)).get<StructVarDef>(i), indentation + 2);
        i++;
    };
};

func parseStructTypeExpr(parser: &Parser) : TypeExpr = {
    parser.lexer.takeWhitespace();
    start: u64 = parser.lexer.index;
    parser.lexer.require('{');
    parser.lexer.takeWhitespace();
    s_vardefs: <StructVarDef> VariableArray = variablearray#new<StructVarDef>();
    while !(parser.lexer.isEof()) && parser.lexer.peekChar() != '}' {
        name: LexString = parser.lexer.takeIdentifier();
        if (&name).len == 0 { panic("Expected a name for a struct vardef"); };
        parser.lexer.takeWhitespace();
        parser.lexer.require(':');
        parser.lexer.takeWhitespace();
        type: TypeExpr = parser.parseType();
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != '}' {
            parser.lexer.require(',');
        };
        parser.lexer.takeWhitespace();
        s: StructVarDef;
        (&s).name = name;
        (&s).type = type;
        (&s_vardefs).append<StructVarDef>(s);
    };
    parser.lexer.require('}');
    end: u64 = parser.lexer.index;
    s: StructTypeExpr;
    (&s).types = s_vardefs;
    
    t: TypeExpr;
    (&t).variant = TypeType#Struct;
    (&t).source = lexstring#new(parser.lexer, start, end);
    (&t).value = (s.flatCopy<StructTypeExpr>()) as &u8;

    t
};

func debugTemplateTypeExpr(ty: &TemplateTypeExpr, indentation: u64);

func debugTypeExprInternal(ty: &TypeExpr, indentation: u64) = {
  /* printIndentation(indentation); */
    if ty.variant == TypeType#Reference {
        printf("& ");
        debugTypeExprInternal((ty.value) as &TypeExpr, indentation);
    } else if ty.variant == TypeType#Named {
        nte: &NamedTypeExpr = (ty.value) as &NamedTypeExpr;
        rendered: &u8 = (&(nte.name)).render();
        printf(rendered);
        free rendered;
    } else if ty.variant == TypeType#Template {
        debugTemplateTypeExpr((ty.value) as &TemplateTypeExpr, indentation);
    } else if ty.variant == TypeType#Struct {
        debugStructTypeExpr((ty.value) as &StructTypeExpr, indentation);
    } else {
        printf("Dunno how to debug this type type")
    }
};

func debugTypeExpr(ty: &TypeExpr, indentation: u64) = {
    printIndentation(indentation);
    debugTypeExprInternal(ty, indentation);
};

func debugTemplateTypeExpr(ty: &TemplateTypeExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TEMPLATE:");
    i: u64 = 0;
    while i < (&(ty.types)).len {
        debugTypeExpr((&(ty.types)).get<TypeExpr>(i), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("UNDERLYING:");
    debugTypeExpr(&(ty.value), indentation + 2);
};

prefix copy(ty: TypeExpr) : &TypeExpr = ty.flatCopy<TypeExpr>();
prefix copy(ty: NamedTypeExpr) : &NamedTypeExpr = ty.flatCopy<NamedTypeExpr>();
prefix copy(ty: TemplateTypeExpr) : &TemplateTypeExpr = ty.flatCopy<TemplateTypeExpr>();


func parseTemplateList(parser: &Parser) : <TypeExpr> VariableArray = {
    parser.lexer.require('<');
    types: <TypeExpr> VariableArray = variablearray#new<TypeExpr>();
    parser.lexer.takeWhitespace();
    while (parser.lexer.peekChar() != '>') && !(parser.lexer.isEof()) {
      (&types).append<TypeExpr>(parser.parseType());
      parser.lexer.takeWhitespace();
      if parser.lexer.peekChar() != '>' {
        parser.lexer.require(',');
        parser.lexer.takeWhitespace();
      };
    };
    parser.lexer.require('>');
    parser.lexer.takeWhitespace();
    types
};

func parseType(parser: &Parser) : TypeExpr = {
  parser.lexer.takeWhitespace();
  c: u8 = parser.lexer.peekChar();
  if c == '&' {
    // ah its a uhh
    // pointer!
    parser.lexer.takeChar();
    parser.lexer.takeWhitespace();
    ty_: TypeExpr = parser.parseType();
    ty: &TypeExpr = copy ty_;
    res: TypeExpr;
    (&res).variant = TypeType#Reference;
    (&res).value = (ty as &u8);
    res
  } else if c == '<' {
    t: TemplateTypeExpr;
    (&t).types = parser.parseTemplateList();
    (&t).value = parser.parseType();
    ty: TypeExpr;
    (&ty).variant = TypeType#Template;
    (&ty).value = (copy t) as &u8;
    ty
  } else if c == '{' {
    t: TypeExpr = parser.parseStructTypeExpr();
    t
  } else {
    // TODO: structs, funcs
    name: LexString = parser.lexer.takeIdentifier();
    ty_: NamedTypeExpr;
    (&ty_).name = name;
    ty: &NamedTypeExpr = copy ty_;
    res: TypeExpr;
    (&res).variant = TypeType#Named;
    (&res).value = (ty as &u8);
    res
  }
};

// TODO: all the rest of the types; lambdas; templates

/* type StructTypeExpr { */
    /*  */
/* }; */
//  }}}

enum ExprType = {
    Number,
    Identifier,
    Block,
    String,
    If,
    While,
    Vardef,
    Return,
    Cast,
    CDef,
    PostfixBrackets,
    PrefixCall,
    SuffixCall,
    TemplatedExpr,
    Binary,
    Char
};

type Expr = {
    value: &u8, // something something data pointer
    variant: ExprType
};

type NumberExpr = {
    source: LexString,
    // parsed: u64,
    bitwidth: LexString,
    has_bitwidth: bool,
};

type IdentifierExpr = {
    source: LexString,
    // TODO: namespaces
};
type VardefExpr = {
    source: LexString,
    ty: TypeExpr,
    var: IdentifierExpr,
};

func intoVardefExpr(e: &Expr) : &VardefExpr = {
    if e.variant != ExprType#Vardef {panic("Into-ed vardef, did not get it")};
    (e.value) as &VardefExpr
};

type BlockExpr = {
    source: LexString,
    exprs: <Expr> VariableArray,
    use_last_val: bool,
};

type StringExpr = {
    source: LexString,
    value: &u8,
};

type CharExpr = {
    source: LexString,
    value: u8,
};

type IfExpr = {
    source: LexString,
    cond: Expr,
    then: Expr,
    has_else: bool,
    els: Expr,
};

type WhileExpr = {
    source: LexString,
    cond: Expr,
    then: Expr,
};

type ReturnExpr = {
    source: LexString,
    has_val: bool,
    val: Expr,
};

type CastExpr = {
    source: LexString,
    val: Expr,
    ty: TypeExpr,
};

// TODO: make work with longer than 1-char brackets
type PostfixBracketsExpr = {
    source: LexString,
    val: Expr,
    brack_first: u8,
    brack_last: u8,
    args: <Expr> VariableArray,
};

type PrefixCallExpr = {
    source: LexString,
    val: Expr,
    prefix: IdentifierExpr,
};

type SuffixCallExpr = {
    source: LexString,
    val: Expr,
    suffix: IdentifierExpr,
};

type TemplatedExpr = {
    types: <TypeExpr> VariableArray,
    val: Expr,
};

type BinaryExpr = {
    lhs: Expr,
    rhs: Expr,
    op: IdentifierExpr,
};

// type CDefExpr


// lexer is moved
func parser#new(lexer: &Lexer) : Parser = {
    parser: Parser;
    (&parser).lexer = lexer;
    (&parser).brackets = variablearray#new<u8>();
    (&parser).prefixes = variablearray#new<&u8>();
    (&parser).suffixes = variablearray#new<&u8>();
    (&((&parser).brackets)).append<u8>('(');
    (&((&parser).brackets)).append<u8>(')');
    (&((&parser).prefixes)).append<&u8>("&");
    (&((&parser).prefixes)).append<&u8>("*");
    (&((&parser).prefixes)).append<&u8>("return");
    (&parser).binaries = hmlist#new<&u8, u64>("+", 50);
    (&((&parser).binaries)).hmlist_add<&u8, u64>(".", 1000);
    // TODO: THIS IS TESTING PLZ REMOVE
    // (&((&parser).prefixes)).append<&u8>("free");
    // (&((&parser).suffixes)).append<&u8>("_s");

    parser
};

overloadable func debugExprType(val: &ExprType, indentation: u64) = {
    printIndentation(indentation);
    if *val == ExprType#Number {
        printf("ExprType#Number");
    } else if *val == ExprType#Identifier {
        printf("ExprType#Identifier");
    } else if *val == ExprType#Block {
        printf("ExprType#Block");
    } else if *val == ExprType#String {
        printf("ExprType#String");
    } else if *val == ExprType#If {
        printf("ExprType#If");
    } else if *val == ExprType#While {
        printf("ExprType#While");
    } else if *val == ExprType#Vardef {
        printf("ExprType#Vardef");
    } else if *val == ExprType#Return {
        printf("ExprType#Return");
    } else if *val == ExprType#Cast {
        printf("ExprType#Cast");
    } else if *val == ExprType#PostfixBrackets {
        printf("ExprType#PostfixBrackets");
    } else if *val == ExprType#PrefixCall {
        printf("ExprType#PrefixCall");
    } else if *val == ExprType#SuffixCall {
        printf("ExprType#SuffixCall");
    } else if *val == ExprType#TemplatedExpr {
        printf("ExprType#TemplatedExpr");
    } else if *val == ExprType#Binary {
        printf("ExprType#Binary");
    } else if *val == ExprType#Char {
        printf("ExprType#Char");
    } else {
        printf("Debug expr type for this one not implmented yet");
    }
};


// forward-def
func parsePrimaryExpr(parser: &Parser) : Expr;
// GOT HERE, need to forward-def overloadbles
func debugBlockExpr(val: &BlockExpr, indentation: u64);
func debugIdentifierExpr(val: &IdentifierExpr, indentation: u64);
func debugVardefExpr(val: &VardefExpr, indentation: u64);
func debugNumberExpr(val: &NumberExpr, indentation: u64);
func debugStringExpr(val: &StringExpr, indentation: u64);
func debugIfExpr(val: &IfExpr, indentation: u64);
func debugWhileExpr(val: &WhileExpr, indentation: u64);
func debugReturnExpr(val: &ReturnExpr, indentation: u64);
func debugCastExpr(val: &CastExpr, indentation: u64);
func debugPostfixBracketsExpr(val: &PostfixBracketsExpr, indentation: u64);
func debugPrefixCallExpr(val: &PrefixCallExpr, indentation: u64);
func debugSuffixCallExpr(val: &SuffixCallExpr, indentation: u64);
func debugTemplatedExpr(t: &TemplatedExpr, indentation: u64);
func debugBinaryExpr(b: &BinaryExpr, indentation: u64);
func debugCharExpr(c: &CharExpr, indentation: u64);

overloadable func debugExpr(val: &Expr, indentation: u64) = {
    debugExprType(&(val.variant), indentation);
    if val.variant == ExprType#Block {
        debugBlockExpr((val.value) as &BlockExpr, indentation);
    } else if val.variant == ExprType#Identifier {
        debugIdentifierExpr((val.value) as &IdentifierExpr, indentation);
    } else if val.variant == ExprType#Number {
        debugNumberExpr((val.value) as &NumberExpr, indentation);
    } else if val.variant == ExprType#String {
        debugStringExpr((val.value) as &StringExpr, indentation);
    } else if val.variant == ExprType#If {
        debugIfExpr((val.value) as &IfExpr, indentation);
    } else if val.variant == ExprType#While {
        debugWhileExpr((val.value) as &WhileExpr, indentation);
    } else if val.variant == ExprType#Vardef {
        debugVardefExpr((val.value) as &VardefExpr, indentation);
    } else if val.variant == ExprType#Return {
        debugReturnExpr((val.value) as &ReturnExpr, indentation);
    } else if val.variant == ExprType#Cast {
        debugCastExpr((val.value) as &CastExpr, indentation);
    } else if val.variant == ExprType#PostfixBrackets {
        debugPostfixBracketsExpr((val.value) as &PostfixBracketsExpr, indentation);
    } else if val.variant == ExprType#PrefixCall {
        debugPrefixCallExpr((val.value) as &PrefixCallExpr, indentation);
    } else if val.variant == ExprType#SuffixCall {
        debugSuffixCallExpr((val.value) as &SuffixCallExpr, indentation);
    } else if val.variant == ExprType#TemplatedExpr {
        debugTemplatedExpr((val.value) as &TemplatedExpr, indentation);
    } else if val.variant == ExprType#Binary {
        debugBinaryExpr((val.value) as &BinaryExpr, indentation);
    } else {
        printf("Dunno how to debug this type");
    }
};

prefix drop(expr: Expr) = {
    free (&expr.value);
};

func parseExpr(parser: &Parser) : Expr;

func debugNumberExpr(val: &NumberExpr, indentation: u64) = {
    debugLexString(&(val.source), indentation);
    if val.has_bitwidth {
        printIndentation(indentation);
        printf("BW");
        debugLexString(&(val.bitwidth), indentation);
    };
};

func parseNumberExpr(parser: &Parser) : NumberExpr = {
    // debugPrint("Parsing number\n");
    number: LexString = parser.lexer.takeNumber();
    if &number.len == 0 {
        panic("Expected number");
    };
    bitwidth: LexString;
    has_bitwidth: bool = false;
    if parser.lexer.peekChar() == '_' {
        parser.lexer.takeChar();
        bitwidth = parser.lexer.takeNumber();
    };

    expr: NumberExpr;
    &expr.source = number;
    &expr.bitwidth = bitwidth;
    &expr.has_bitwidth = has_bitwidth;

    // TODO: atoi

    expr
};

prefix copy(val: NumberExpr) : &NumberExpr = {
    data: &NumberExpr = malloc(@sizeof(NumberExpr)) as &NumberExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(NumberExpr));

    data
};

overloadable func asExpr(number: NumberExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Number;

    // TODO: make it more silvery
    &expr.value = (copy number) as &u8;

    expr
};


func debugIdentifierExpr(val: &IdentifierExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("`");
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    printf("`");
    // debugLexString(&(val.source), indentation);
};

func parseIdentifierExpr(parser: &Parser) : IdentifierExpr = {
    // debugPrint("Parsing identifier expr\n");
    id: LexString = parser.lexer.takeIdentifier();
    if &id.len == 0 {
        panic("Expected valid identifier");
    };
    expr: IdentifierExpr;
    &expr.source = id;

    expr
};

prefix copy(val: IdentifierExpr) : &IdentifierExpr = {
    data: &IdentifierExpr = malloc(@sizeof(IdentifierExpr)) as &IdentifierExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(IdentifierExpr));

    data
};

overloadable func asExpr(id: IdentifierExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Identifier;

    &expr.value = (copy id) as &u8;

    expr
};

prefix copy (val: VardefExpr) : &VardefExpr = val.flatCopy<VardefExpr>();

func debugVardefExpr(val: &VardefExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("VARDEF `");
    id: &u8 = (&((&(val.var)).source)).render();
    printf(id);
    free id;
    printf("` DEFINED WITH TYPE");
    debugTypeExpr(&(val.ty), indentation + 2);
};

overloadable func asExpr(v: VardefExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Vardef;
    &expr.value = (copy v) as &u8;

    expr
};

func maybeVardefExpr(parser: &Parser, id: IdentifierExpr) : Expr = {
  parser.lexer.takeWhitespace();
  if parser.lexer.peekChar() == ':' {
    parser.lexer.takeChar();
    parser.lexer.takeWhitespace();
    ty_: TypeExpr = parser.parseType();
    ty: &TypeExpr = copy ty_;
    v_: VardefExpr;
    v: &VardefExpr = &v_;
    v.source = (&id.source) + ty.source;
    v.var = id;
    v.ty = ty_;
    v_.asExpr()
  } else { id.asExpr() }
};

func parseVardefExpr(parser: &Parser) : VardefExpr = {
    id: IdentifierExpr =  parser.parseIdentifierExpr();
    parser.lexer.takeWhitespace();
    if parser.lexer.peekChar() != ':' {panic("Expected ':'");};
    e: Expr = parser.maybeVardefExpr(id);
    if (&e).variant != ExprType#Vardef {panic("something is quite wrong")};
    *(((&e).value) as &VardefExpr)
};

func debugBlockExpr(val: &BlockExpr, indentation: u64) = {
    printIndentation(indentation);
    exprs: <Expr> VariableArray;
    exprs = val.exprs;

    printf("BLOCK: {");
    i: u64 = 0;
    while i < (&exprs).len {
        debugExpr(((&(val.exprs)).get<Expr>(i)), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("} using last value: ");
    printf(
        if val.use_last_val {
          "true"
        } else { "false" }
    );
};

func parseBlockExpr(parser: &Parser) : BlockExpr = {
    // debugPrint("Parsing block expr\n");
    parser.lexer.takeWhitespace();

    start: u64 = parser.lexer.index;
    
    parser.lexer.require('{');
    expr: BlockExpr;
    exprs: <Expr> VariableArray = variablearray#new<Expr>();

    last_semicolon: bool = true;

    while !(parser.lexer.isEof()) && (parser.lexer.peekChar() != '}') {
        internal_expr: Expr = parser.parseExpr();
        (&exprs).append<Expr>(internal_expr);
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() == '}' {
            last_semicolon = false;
            break;
        };
        // Don't require semicolons after blocks
        if &internal_expr.variant != ExprType#Block {
          parser.lexer.require(';')
        } else {
            if parser.lexer.peekChar() == ';' {
                parser.lexer.require(';');
            };
        };
        parser.lexer.takeWhitespace();
    };

    parser.lexer.require('}');
//    printf("len: ");
//    printint((&exprs).len);

    end: u64 = parser.lexer.index;

    (&expr).exprs = exprs;
    (&expr).source = lexstring#new(parser.lexer, start, end);
    (&expr).use_last_val = !last_semicolon;

    expr
};

prefix copy(val: BlockExpr) : &BlockExpr = {
    data: &BlockExpr = malloc(@sizeof(BlockExpr)) as &BlockExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(BlockExpr));

    data
};

overloadable func asExpr(id: BlockExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#Block;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugStringExpr(val: &StringExpr, indentation: u64) = {
    printIndentation(indentation);    
  /* printf("`"); */
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseStringExpr(parser: &Parser) : StringExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('"');

    str: <u8> VariableArray = variablearray#new<u8>();
    escaped: bool = false;
    while !(parser.lexer.isEof()) && (!((parser.lexer.peekChar() == '"') && (!(escaped)))) {
        next_char: u8 = parser.lexer.takeChar();
        if escaped {
            (&str).append<u8>(next_char);
            escaped = false;
        } else {
            if next_char == '\\' {
                escaped = true;
            } else {
                (&str).append<u8>(next_char);
            }
        }
    };

    parser.lexer.require('"');

    end: u64 = parser.lexer.index;
    s: StringExpr;
    (&s).source = lexstring#new(parser.lexer, start, end);
    (&s).value = (&str).data;

    s
};

prefix copy(val: StringExpr) : &StringExpr = {
    data: &StringExpr = malloc(@sizeof(StringExpr)) as &StringExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(StringExpr));

    data
};

overloadable func asExpr(id: StringExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#String;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugCharExpr(val: &CharExpr, indentation: u64) = {
    printIndentation(indentation);    
  /* printf("`"); */
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseCharExpr(parser: &Parser) : CharExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('\'');

    char: u8 = parser.lexer.takeChar();
    if char == '\\' {
        char = parser.lexer.takeChar();
    };

    parser.lexer.require('\'');

    end: u64 = parser.lexer.index;
    s: CharExpr;
    (&s).source = lexstring#new(parser.lexer, start, end);
    (&s).value = char;

    s
};

prefix copy(val: CharExpr) : &CharExpr = {
    data: &CharExpr = malloc(@sizeof(CharExpr)) as &CharExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(CharExpr));

    data
};

overloadable func asExpr(id: CharExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#Char;
    (&expr).value = (copy id) as &u8;

    expr
};



func debugIfExpr(val: &IfExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("IF: ");
    debugExpr(&(val.cond), indentation + 2);
    printIndentation(indentation);
    printf("THEN: ");
    debugExpr(&(val.then), indentation + 2);
    if (val.has_else) {
      printIndentation(indentation);
      printf("ELSE: ");
      debugExpr(&(val.els), indentation + 2);
    };
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseIfExpr(parser: &Parser) : IfExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("if");
    
    cond: Expr = parseExpr(parser);
    then: Expr = parseExpr(parser);
    parser.lexer.takeWhitespace();

    els: Expr;
    peek_: Lexer = parser.lexer.peek();
    peeked: &Lexer = &peek_;
    n_id: LexString = peeked.takeIdentifier();
    next: &u8 = (&n_id).render();
    has_else: bool = if next == "else" {
        parser.lexer.takeIdentifier();
        els = parser.parseExpr();
        true
    } else false;

    free next;

    end: u64 = parser.lexer.index;
    i: IfExpr;
    (&i).source = lexstring#new(parser.lexer, start, end);
    (&i).cond = cond;
    (&i).then = then;
    (&i).els = els;
    (&i).has_else = has_else;

    i
};

prefix copy(val: IfExpr) : &IfExpr = flatCopy<IfExpr>(val);

overloadable func asExpr(id: IfExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#If;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugWhileExpr(val: &WhileExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("WHILE: ");
    debugExpr(&(val.cond), indentation + 2);
    printIndentation(indentation);
    printf("DO: ");
    debugExpr(&(val.then), indentation + 2);
};

func parseWhileExpr(parser: &Parser) : WhileExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("while");
    
    cond: Expr = parseExpr(parser);
    then: Expr = parseExpr(parser);

    end: u64 = parser.lexer.index;
    w: WhileExpr;
    (&w).source = lexstring#new(parser.lexer, start, end);
    (&w).cond = cond;
    (&w).then = then;
    w
};

prefix copy(val: WhileExpr) : &WhileExpr = flatCopy<WhileExpr>(val);

overloadable func asExpr(id: WhileExpr) : Expr = {
  expr: Expr;
  (&expr).variant = ExprType#While;
  (&expr).value = (copy id) as &u8;

  expr
};

func debugReturnExpr(val: &ReturnExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("RETURN ");
    if val.has_val {
        printf("VAL");
        debugExpr(&(val.val), indentation + 2);
    } else {
        printf("NONE");
    };
};

func parseReturnExpr(parser: &Parser) : ReturnExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("return");

    parser.lexer.takeWhitespace();
    c: u8 = parser.lexer.peekChar();
    has_val: bool = !((c == ';') || (c == '}'));

    val: Expr;

    if has_val {
        val = parser.parseExpr();
    };

    end: u64 = parser.lexer.index;

    r: ReturnExpr;
    (&r).has_val = has_val;
    (&r).val = val;
    (&r).source = lexstring#new(parser.lexer, start, end);
    r
};

prefix copy(val: ReturnExpr) : &ReturnExpr = flatCopy<ReturnExpr>(val);

overloadable func asExpr(id: ReturnExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#Return;
    (&expr).value = (copy id) as &u8;

    expr
};

prefix copy (val: CastExpr) : &CastExpr = val.flatCopy<CastExpr>();

func debugCastExpr(val: &CastExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("CAST");
    (&(val.val)).debugExpr(indentation + 2);
    printIndentation(indentation);
    printf("TO");
    debugTypeExpr(&(val.ty), indentation + 2);
};

overloadable func asExpr(v: CastExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Cast;
    &expr.value = (copy v) as &u8;

    expr
};

func maybeCastExpr(parser: &Parser, e: Expr) : Expr = {
  start: u64 = parser.lexer.index;
  parser.lexer.takeWhitespace();
  peeked: Lexer = parser.lexer.peek();
  next: &u8;
  ls: LexString = (&peeked).takeIdentifier();
  next = (&ls).render();
  ex: Expr = if next == "as" {
    parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    ty_: TypeExpr = parser.parseType();
    ty: &TypeExpr = copy ty_;
    v_: CastExpr;
    v: &CastExpr = &v_;
    v.source = lexstring#new(parser.lexer, start, parser.lexer.index);
    v.val = e;
    v.ty = ty_;
    v_.asExpr()
  } else { e };
  free next;
  ex
};

func debugPostfixBracketsExpr(val: &PostfixBracketsExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("POSTFIX BRACKETS:");
    printIndentation(indentation);
    putchar(val.brack_first);
    putchar(' ');
    putchar(val.brack_last);

    printIndentation(indentation);
    printf("UPON:");
    debugExpr(&(val.val), indentation + 2);
    printIndentation(indentation);
    printf("ARGS:");
    i: u64 = 0;
    while i < (&(val.args)).len {
        debugExpr((&(val.args)).get<Expr>(i), indentation + 2);
        i++;
    };
    
};

prefix copy(v: PostfixBracketsExpr) : &PostfixBracketsExpr = flatCopy<PostfixBracketsExpr>(v);

overloadable func asExpr(v: PostfixBracketsExpr) : Expr = {
    e: Expr;
    (&e).variant = ExprType#PostfixBrackets;
    (&e).value = (copy v) as &u8;

    e
};

func maybePostfixBracketsExpr(parser: &Parser, e: Expr) : Expr = {
    start: u64 = parser.lexer.index;
    /*
    parser.lexer.takeWhitespace();
    peeked: Lexer = parser.lexer.peek();
    ls: LexString = (&peeked).takeIdentifier();
    first: &u8 = (&ls).render();
    */
    first: u8 = parser.lexer.peekChar();
    if !((&(parser.brackets)).va_contains<u8>(first)) { return e; };
    idx: u64 = (&(parser.brackets)).va_indexof<u8>(first);
    if (idx % 2) != 0 {return e;};
    last: u8 = *((&(parser.brackets)).get<u8>(idx + 1));
    // skreeee
    // id_first: IdentifierExpr = parser.parseIdentifierExpr();
    parser.lexer.takeChar();
    parser.lexer.takeWhitespace();

    exprs: <Expr> VariableArray = variablearray#new<Expr>();

    while !(parser.lexer.isEof()) && !({
        parser.lexer.peekChar() == last
    }) {
        internal_expr: Expr = parser.parseExpr();
        (&exprs).append<Expr>(internal_expr);
        parser.lexer.takeWhitespace();
        if {
            parser.lexer.peekChar() == last
        } {
            break;
        };
        parser.lexer.require(',');

        parser.lexer.takeWhitespace();
    };

    parser.lexer.require(last);

    ex: PostfixBracketsExpr;
    (&ex).source = lexstring#new(parser.lexer, start, parser.lexer.index);
    (&ex).val = e;
    (&ex).brack_first = first;
    (&ex).brack_last = last;
    (&ex).args = exprs;


    ex.asExpr()
};

func debugPrefixCallExpr(p: &PrefixCallExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("PREFIX CALL:");
    debugIdentifierExpr(&(p.prefix), indentation + 2);
    printIndentation(indentation);
    printf("UPON");
    debugExpr(&(p.val), indentation + 2);
};

prefix copy(p: PrefixCallExpr) : &PrefixCallExpr = p.flatCopy<PrefixCallExpr>();

overloadable func asExpr(p: PrefixCallExpr) : Expr = {
    e: Expr;
    (&e).variant = ExprType#PrefixCall;
    (&e).value = (copy p) as &u8;
    e
};

func maybePrefixCallExpr(parser: &Parser, i: IdentifierExpr) : Expr = {
    r: &u8 = (&((&i).source)).render(); /*
    printf("Trying");
    printf(r);
    j: u64 = 0;
    while j < (&(parser.prefixes)).len {
        printf("\n ");
        printf(*((&(parser.prefixes)).get<&u8>(j)));
        j++;
    }; */
    if (&(parser.prefixes)).va_contains<&u8>(r) {
      // printf("PREFIXED");
      free r;
        p: PrefixCallExpr;
        (&p).prefix = i;
        (&p).val = parser.parsePrimaryExpr();
        end: u64 = parser.lexer.index;
        start: u64 = (&((&i).source)).offset;
        (&p).source = lexstring#new(parser.lexer, start, end);
        p.asExpr()
    } else {
      free r;
      i.asExpr()
    }
};

func debugSuffixCallExpr(p: &SuffixCallExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("SUFFIX CALL:");
    debugIdentifierExpr(&(p.suffix), indentation + 2);
    printIndentation(indentation);
    printf("UPON");
    debugExpr(&(p.val), indentation + 2);
};

// prefix copy(s: SuffixCallExpr) : &SuffixCallExpr = s.flatCopy<SuffixCallExpr>();
//prefix copy(s: SuffixCallExpr) : &SuffixCallExpr = flatCopy<SuffixCallExpr>(s);
// IDK why it no work as other one
prefix copy(s: SuffixCallExpr) : &SuffixCallExpr = {
  a: &SuffixCallExpr = flatCopy<SuffixCallExpr>(s);
  a
};
// prefix copy(s: )

// again IDK why
overloadable func sf_asExpr(p: SuffixCallExpr) : Expr = {
    e: Expr;
    (&e).variant = ExprType#SuffixCall;
    (&e).value = (copy p) as &u8;
    e
};

func maybeSuffixCallExpr(parser: &Parser, e: Expr) : Expr = {
    parser.lexer.takeWhitespace();
    l: Lexer = parser.lexer.peek();
    ls: LexString = (&l).takeIdentifier();
    sf: &u8 = (&ls).render();
    if (&(parser.suffixes)).va_contains<&u8>(sf) {
        free sf;
        start: u64 = parser.lexer.index;
        s: SuffixCallExpr;
        (&s).suffix = parser.parseIdentifierExpr();
        (&s).val = e;
        end: u64 = parser.lexer.index;
        (&s).source = lexstring#new(parser.lexer, start, end);
        s.sf_asExpr()
    } else {
      free sf;
      e
    }
};

prefix copy(t: TemplatedExpr) : &TemplatedExpr = t.flatCopy<TemplatedExpr>();

overloadable func asExpr(t: TemplatedExpr) : Expr = {
    ex: Expr;
    (&ex).variant = ExprType#TemplatedExpr;
    (&ex).value = (copy t) as &u8;
    ex
};

func debugTemplatedExpr(t: &TemplatedExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TEMPLATED EXPR:");
    i: u64 = 0;
    while i < (&(t.types)).len {
        debugTypeExpr((&(t.types)).get<TypeExpr>(i), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("UNDERLYING:");
    debugExpr(&(t.val), indentation + 2);
};

func maybeTemplatedExpr(parser: &Parser, e: Expr) : Expr = {
    // janks af. forgive me
    ls: LexString = lexstring#new(parser.lexer, parser.lexer.index - 1, parser.lexer.index);
    if (&ls).render() == " " {return e};
    if parser.lexer.peekChar() == '<' {
        types: <TypeExpr> VariableArray = parser.parseTemplateList();
        t: TemplatedExpr;
        (&t).types = types;
        (&t).val = e;
        t.asExpr()
    } else {e}
};

// DOES NOT HANDLE BINARY SHENANIGANS

func parsePrimaryExpr(parser: &Parser) : Expr = {
    parser.lexer.takeWhitespace();

    next_char: u8 = parser.lexer.peekChar();
    ex: Expr = if next_char.isNumeric() {
        parser.parseNumberExpr().asExpr()
    } else if next_char == '(' {
        parser.lexer.takeChar();
        e: Expr = parser.parseExpr();
        parser.lexer.takeWhitespace();
        parser.lexer.require(')');
        e
    } else if (next_char.isConventionalId(true) || next_char.isSpecialId()) {
        peeked_: Lexer = (parser.lexer.peek());
        peeked: &Lexer = &peeked_;
        nextTok: LexString = peeked.takeIdentifier();
        next: &u8 = (&nextTok).render();
        e: Expr = if next == "if" {parser.parseIfExpr().asExpr()}
        else if next == "while" {parser.parseWhileExpr().asExpr()}
        else if next == "return" {parser.parseReturnExpr().asExpr()}
        else {
          id: IdentifierExpr = parser.parseIdentifierExpr();
          v: Expr = parser.maybeVardefExpr(id);
          if (&v).variant == ExprType#Identifier {
            v = parser.maybePrefixCallExpr(id);
          };
          v
        };
        free next;
        e
    } else if next_char == '{' {
        ba: BlockExpr = parser.parseBlockExpr();
        e: Expr = ba.asExpr();
        e
    } else if next_char == '"' {
      parser.parseStringExpr().asExpr()
    } else if next_char == '\'' {
      parser.parseCharExpr().asExpr()
    } else {
        expr: Expr;
        printf("Cannot parse: `");
        putchar(next_char);
        printf("`\n");
        panic();

        expr
    };
    // TODO: fix this, maybe iterate until no changes?
    ex = parser.maybeTemplatedExpr(ex);
    ex = parser.maybePostfixBracketsExpr(ex);
    ex = parser.maybeSuffixCallExpr(ex);
    ex = parser.maybeCastExpr(ex);
    ex
};

prefix copy(b: BinaryExpr) : &BinaryExpr = b.flatCopy<BinaryExpr>();

func asExpr(b: BinaryExpr) : Expr = {
    ex: Expr;
    (&ex).variant = ExprType#Binary;
    (&ex).value = (copy b) as &u8;

    ex
};

func debugBinaryExpr(b: &BinaryExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("BINARY:");
    debugIdentifierExpr(&(b.op), indentation + 2);
    printIndentation(indentation);
    printf("LHS:");
    debugExpr(&(b.lhs), indentation + 2);
    printIndentation(indentation);
    printf("RHS:");
    debugExpr(&(b.rhs), indentation + 2);
};

func parseBinary(parser: &Parser, lhs_: Expr, current_prec: u64) : Expr = {
    lhs: Expr = lhs_;
    while true {
      parser.lexer.takeWhitespace();
      peekl: Lexer = parser.lexer.peek();
      id: LexString = (&peekl).takeIdentifier();
      peeked: &u8 = (&id).render();
      if !((&(parser.binaries)).hmlist_contains<&u8, u64>(peeked)) { free peeked; return lhs; };
      their_prec: u64 = *((&(parser.binaries)).hmlist_get<&u8, u64>(peeked));
      free peeked;
      if current_prec > their_prec { return lhs; };
      // okay take it
      op: IdentifierExpr = parser.parseIdentifierExpr();
      // and the rhs
      rhs: Expr = parser.parsePrimaryExpr();

      // identity theft
      our_prec: u64 = their_prec;

      parser.lexer.takeWhitespace();
      peekl = parser.lexer.peek();
      id = (&peekl).takeIdentifier();
      peeked = (&id).render();
    
      // TODO: negative numbers (!)
      their_prec = if !((&(parser.binaries)).hmlist_contains<&u8, u64>(peeked)) { 0 }
      else { *((&(parser.binaries)).hmlist_get<&u8, u64>(peeked)) };

      // if theirs is bigger than ours consider it first
      rhs = if their_prec > our_prec { parser.parseBinary(rhs, our_prec) }
      else { rhs };

      lhsnew: BinaryExpr;
      (&lhsnew).lhs = lhs;
      (&lhsnew).rhs = rhs;
      (&lhsnew).op = op;

      lhs = lhsnew.asExpr();
    };

    lhs
};

func parseExpr(parser: &Parser) : Expr = parser.parseBinary(parser.parsePrimaryExpr(), 0);

// }}}

// TL-PARSING {{{

// HINTS {{{
// TODO: use hashmap
type Hints = {
    source: LexString,
    names: <LexString> VariableArray,
    values: <Expr> VariableArray,
};

func debugHints(h: &Hints, indentation: u64) = {
    printIndentation(indentation);
    printf("HINTS:");
    // debugLexString(&(h.name), indentation);
    i: u64 = 0;
    while i < (&(h.values)).len {
        debugLexString((&(h.names)).get<LexString>(i), indentation + 2);
        debugExpr((&(h.values)).get<Expr>(i), indentation + 2);
        i++;
    };
};

func parseHints(parser: &Parser) : Hints = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('#');
    parser.lexer.takeWhitespace();
    names: <LexString> VariableArray = variablearray#new<LexString>();
    values: <Expr> VariableArray = variablearray#new<Expr>();
    while parser.lexer.peekChar() != ';' {
        name: LexString = parser.lexer.takeIdentifier();
        (&names).append<LexString>(name);
        parser.lexer.takeWhitespace();
        (&values).append<Expr>(parser.parseExpr());
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != ';' {parser.lexer.require(',');};
        parser.lexer.takeWhitespace();
    };
    end: u64 = parser.lexer.index;

    h: Hints;
    // (&h).name = name;
    (&h).values = values;
    (&h).names = names;
    (&h).source = lexstring#new(parser.lexer, start, end);
    h
};

// }}}
// TEMPLATES {{{

type TemplateExpr = {
    source: LexString,
    args: <LexString> VariableArray,
};

func parseTemplate(parser: &Parser) : TemplateExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('<');
    parser.lexer.takeWhitespace();
    v: <LexString> VariableArray = variablearray#new<LexString>();
    while parser.lexer.peekChar() != '>' {
        (&v).append<LexString>(parser.lexer.takeIdentifier());
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != '>' {
          parser.lexer.require(',');
          parser.lexer.takeWhitespace();
        };
    };
    parser.lexer.require('>');

    t: TemplateExpr;
    (&t).source = lexstring#new(parser.lexer, start, parser.lexer.index);
    (&t).args = v;

    t
};

func debugTemplateExpr(t: &TemplateExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TEMPLATE:");
    i: u64 = 0;
    while i < (&(t.args)).len {
        debugLexString((&(t.args)).get<LexString>(i), indentation + 2);
        i++
    };
};

// }}}

enum TLExprType = {
    CDef,
    Function,
    Typedef,
    Enum,
};

type TLExpr = {
    variant: TLExprType,
    hints: <Hints> VariableArray,
    value: &u8,
    template: TemplateExpr,
    has_template: bool,
};

type EnumTLExpr = {
    source: LexString,
    names: <IdentifierExpr> VariableArray,
    name: LexString,
};

prefix copy(e: EnumTLExpr) : &EnumTLExpr = e.flatCopy<EnumTLExpr>();
overloadable func asTLExpr(e: EnumTLExpr) : TLExpr = {
    t: TLExpr;
    (&t).variant = TLExprType#Enum;
    (&t).value = (copy e) as &u8;

    t
};

func debugEnumTLExpr(e: &EnumTLExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("ENUM:");
    debugLexString(&(e.name), indentation);
    i: u64 = 0;
    while i < (&(e.names)).len {
        debugIdentifierExpr((&(e.names)).get<IdentifierExpr>(i), indentation + 2);
        i++
    };
};

func parseEnumTLExpr(parser: &Parser) : EnumTLExpr = {
    start: u64 = parser.lexer.index;
    l: LexString = (parser.lexer.takeIdentifier());
    kwd: &u8 = (&l).render();
    if kwd != "enum" {
        panic("Expected `enum`");
    };
    parser.lexer.takeWhitespace();
    name: LexString = parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    parser.lexer.require('=');
    parser.lexer.takeWhitespace();
    parser.lexer.require('{');
    parser.lexer.takeWhitespace();
    
    names: <IdentifierExpr> VariableArray = variablearray#new<IdentifierExpr>();

    while !(parser.lexer.isEof()) && parser.lexer.peekChar() != '}' {
          (&names).append<IdentifierExpr>(parser.parseIdentifierExpr());
          parser.lexer.takeWhitespace();
          if parser.lexer.peekChar() != '}' {
              parser.lexer.require(',');
              parser.lexer.takeWhitespace();
          };
    };

    parser.lexer.require('}');

    end: u64 = parser.lexer.index;

    e: EnumTLExpr;
    (&e).source = lexstring#new(parser.lexer, start, end);
    (&e).names = names;
    (&e).name = name;

    e
};

type TypedefTLExpr = {
    source: LexString,
    name: LexString,
    ty: TypeExpr,
};

prefix copy(t: TypedefTLExpr) : &TypedefTLExpr = t.flatCopy<TypedefTLExpr>();
overloadable func asTLExpr(t: TypedefTLExpr) : TLExpr = {
    e: TLExpr;
    (&e).variant = TLExprType#Typedef;
    (&e).value = (copy t) as &u8;

    e
};

func debugTypedefTLExpr(t: &TypedefTLExpr, indentation: u64) = {
    printf("\nTYPEDEF:");
    debugLexString(&(t.name), indentation);
    debugTypeExpr(&(t.ty), indentation);
};

func parseTypedefTLExpr(parser: &Parser) : TypedefTLExpr = {
    start: u64 = parser.lexer.index;
    l: LexString = (parser.lexer.takeIdentifier());
    kwd: &u8 = (&l).render();
    if kwd != "type" {
        printf("got ");printf(kwd);
        panic("Expected `type`");
    };
    parser.lexer.takeWhitespace();
    name: LexString = parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    parser.lexer.require('=');
    parser.lexer.takeWhitespace();
    t: TypeExpr = parser.parseType();

    end: u64 = parser.lexer.index;

    e: TypedefTLExpr;
    (&e).source = lexstring#new(parser.lexer, start, end);
    (&e).ty = t;
    (&e).name = name;

    e
};

enum FnProtoType = {
    Infix,
    Suffix,
    Prefix,
    Brackets,
    Normal
};

func debugFnProtoType(f: FnProtoType, indentation: u64) = {
    printIndentation(indentation);
    if f == FnProtoType#Infix {printf("FnProtoType#Infix");}
    else if f == FnProtoType#Suffix {printf("FnProtoType#Suffix");}
    else if f == FnProtoType#Prefix {printf("FnProtoType#Prefix");}
    else if f == FnProtoType#Brackets {printf("FnProtoType#Brackets");}
    else if f == FnProtoType#Normal {printf("FnProtoType#Normal");}
    else {printf("Don't know how to debug this FnProtoType");}
};

type FnProto = {
  source: LexString,
  variant: FnProtoType,
  first: LexString,
  last: LexString, // only for bracketed
  args: <VardefExpr> VariableArray,
  has_retty: bool,
  retty: TypeExpr,
  overloadable: bool,
  macro: bool,
};

func debugFnProto(p: &FnProto, indentation: u64) = {
    printIndentation(indentation);
    printf("PROTO");
    if p.overloadable {
        printIndentation(indentation);
        printf("OVERLOADABLE");
    };
    debugFnProtoType(p.variant, indentation);
    debugLexString(&(p.first), indentation);
    if p.variant == FnProtoType#Brackets {debugLexString(&(p.last), indentation);};
    if p.has_retty {debugTypeExpr(&(p.retty), indentation)};
    i: u64 = 0;
    while i < (&(p.args)).len {
        debugVardefExpr((&(p.args)).get<VardefExpr>(i), indentation + 2);
        i++;
    };
};

func parseFnProto(parser: &Parser) : FnProto = {
    start: u64 = parser.lexer.index;
    ty: LexString = parser.lexer.takeIdentifier();
    r: &u8 = (&ty).render();
    overloadable: bool = if r == "overloadable" {free r; parser.lexer.takeWhitespace();
      ty: LexString = parser.lexer.takeIdentifier();
      r = (&ty).render(); true}
    else {false};
    macro: bool = if r == "macro" {free r; parser.lexer.takeWhitespace();
      ty: LexString = parser.lexer.takeIdentifier();
      r = (&ty).render(); true}
    else {false};
    fnty: FnProtoType = if r == "infix" {FnProtoType#Infix}
    else if r == "suffix" {FnProtoType#Suffix}
    else if r == "prefix" {FnProtoType#Prefix}
    else if r == "brackets" {FnProtoType#Brackets}
    else if r == "func" {FnProtoType#Normal}
    else {printf("`"); printf(r); printf("`"); free r; panic("Unknown FnProtoType ");FnProtoType#Normal};
    free r;
    
    parser.lexer.takeWhitespace();
    first: LexString = parser.lexer.takeIdentifier();
    // TODO: sanity checks
    parser.lexer.takeWhitespace();
    last: LexString;
    if fnty == FnProtoType#Brackets {
        last = parser.lexer.takeIdentifier();
        parser.lexer.takeWhitespace();
    };
    parser.lexer.require('(');
    parser.lexer.takeWhitespace();

    args: <VardefExpr> VariableArray = variablearray#new<VardefExpr>();

    while parser.lexer.peekChar() != ')' {
        (&args).append<VardefExpr>(parser.parseVardefExpr());
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != ')' {
            parser.lexer.require(',');
            parser.lexer.takeWhitespace();
        };
    };

    parser.lexer.require(')');

    parser.lexer.takeWhitespace();
    has_retty: bool = false;
    retty: TypeExpr;
    if parser.lexer.peekChar() == ':' {
        has_retty = true;
        parser.lexer.require(':');
        parser.lexer.takeWhitespace();
        retty = parser.parseType();
    };

    fnpr: FnProto;
    (&fnpr).source = lexstring#new(parser.lexer, start, parser.lexer.index);
    (&fnpr).first = first;
    (&fnpr).last = last;
    (&fnpr).args = args;
    (&fnpr).variant = fnty;
    (&fnpr).has_retty = has_retty;
    (&fnpr).overloadable = overloadable;
    (&fnpr).retty = retty;
    (&fnpr).macro = macro;

    fnpr
};

type FnDefTLExpr = {
  proto: FnProto,
  has_body: bool,
  body: Expr,
};

prefix copy(f: FnDefTLExpr) : &FnDefTLExpr = flatCopy<FnDefTLExpr>(f);
overloadable func asTLExpr(f: FnDefTLExpr) : TLExpr = {
    t: TLExpr;
    (&t).variant = TLExprType#Function;
    (&t).value = (copy f) as &u8;

    t
};

func debugFnDefTLExpr(f: &FnDefTLExpr, indentation: u64) = {
  printIndentation(indentation);
  printf("FNDEF");
    (&(f.proto)).debugFnProto(indentation);
    if f.has_body {
        printIndentation(indentation);
        printf("BODY");
        debugExpr(&(f.body), indentation + 2);
    };
};

func parseFnDefTLExpr(parser: &Parser) : FnDefTLExpr = {
  proto: FnProto = parser.parseFnProto();
  parser.lexer.takeWhitespace();
  has_body: bool = false;
  body: Expr;
  if parser.lexer.peekChar() == '=' {
      parser.lexer.require('=');
      body = parser.parseExpr();
      has_body = true;
};
  
  f: FnDefTLExpr;
  (&f).proto = proto;
  (&f).has_body = has_body;
  (&f).body = body;

  f
};


// TL CDEFS {{{
type CDefTLExpr = {
    source: LexString,
    name: LexString,
    values: <Expr> VariableArray,
};

prefix copy(c: CDefTLExpr) : &CDefTLExpr = flatCopy<CDefTLExpr>(c);
overloadable func asTLExpr(c: CDefTLExpr) : TLExpr = {
    t: TLExpr;
    (&t).variant = TLExprType#CDef;
    (&t).value = (copy c) as &u8;

    t
};

func debugCDefTLExpr(h: &CDefTLExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TLCDef:");
    debugLexString(&(h.name), indentation);
    i: u64 = 0;
    while i < (&(h.values)).len {
        debugExpr((&(h.values)).get<Expr>(i), indentation + 2);
        i++;
    };
};

func parseCDefTLExpr(parser: &Parser) : CDefTLExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('@');
    parser.lexer.takeWhitespace();
    name: LexString = parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    parser.lexer.require('(');
    parser.lexer.takeWhitespace();
    values: <Expr> VariableArray = variablearray#new<Expr>();
    while parser.lexer.peekChar() != ')' {
        (&values).append<Expr>(parser.parseExpr());
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != ')' {parser.lexer.require(',');};
    };
    parser.lexer.require(')');
    end: u64 = parser.lexer.index;

    h: CDefTLExpr;
    (&h).name = name;
    (&h).values = values;
    (&h).source = lexstring#new(parser.lexer, start, end);
    h
};

//  }}}

func debugTLExprType(t: TLExprType) = {
    if t == TLExprType#Enum {printf("TLExprType#Enum");}
    else if t == TLExprType#Typedef {printf("TLExprType#Typedef");}
    else if t == TLExprType#Function {printf("TLExprType#Function");}
    else if t == TLExprType#CDef {printf("TLExprType#CDef");}
    else (printf("I don't know how to debug this TLExprType"))
};

func debugTLExpr(t: &TLExpr) = {
    printf("\n");
    printf("Type: ");
    debugTLExprType(t.variant);
    i: u64 = 0;
    while i < (&(t.hints)).len {
        debugHints((&(t.hints)).get<Hints>(i), 0);
        i++
    };
    if t.has_template {
        debugTemplateExpr(&(t.template), 0);
    };
    if t.variant == TLExprType#Enum {
        debugEnumTLExpr((t.value) as &EnumTLExpr, 0);
    } else if t.variant == TLExprType#Typedef {
        debugTypedefTLExpr((t.value) as &TypedefTLExpr, 0);
    } else if t.variant == TLExprType#Function {
        debugFnDefTLExpr((t.value) as &FnDefTLExpr, 0);
    } else if t.variant == TLExprType#CDef {
        debugCDefTLExpr((t.value) as &CDefTLExpr, 0);
    } else {
        printf("Can't debug this TL expr type!");
    }
};

func parseTLExpr(parser: &Parser) : TLExpr = {
    // TODO: hints, cdefs, etc etc
    parser.lexer.takeWhitespace();
    hints: <Hints> VariableArray = variablearray#new<Hints>();
    while parser.lexer.peekChar() == '#' {
        h: Hints = parser.parseHints();
        (&hints).append<Hints>(h);
        // hints.append<Hints>(parser.parseHints());
        parser.lexer.require(';');
        parser.lexer.takeWhitespace();
    };
    has_template: bool = false;
    template: TemplateExpr;
    if parser.lexer.peekChar() == '<' {
        template = parser.parseTemplate();
        has_template = true;
        parser.lexer.takeWhitespace();
    };
    peeked: Lexer = parser.lexer.peek();
    ls: LexString = (&peeked).takeIdentifier();
    next: &u8 = (&ls).render();
    e: TLExpr = if parser.lexer.peekChar() == '@' {
        parser.parseCDefTLExpr().asTLExpr()
    } else if next == "enum" {
        parser.parseEnumTLExpr().asTLExpr()
    } else if next == "type" {
        parser.parseTypedefTLExpr().asTLExpr()
    } else {
        // NOTE: we don't free rend on purpose
        // since it's kept lol

        f: FnDefTLExpr = parser.parseFnDefTLExpr();
        if (&((&f).proto)).variant == FnProtoType#Brackets {
            ls: LexString = (&((&f).proto)).first;
            rend: &u8 = (&ls).render();
            (&(parser.brackets)).append<u8>(*(rend[0]));
            ls = (&((&f).proto)).last;
            rend = (&ls).render();
            (&(parser.brackets)).append<u8>(*(rend[0]));
        } else if (&((&f).proto)).variant == FnProtoType#Prefix {
            ls: LexString = (&((&f).proto)).first;
            rend: &u8 = (&ls).render();
            (&(parser.prefixes)).append<&u8>(rend);
        } else if (&((&f).proto)).variant == FnProtoType#Suffix {
            ls: LexString = (&((&f).proto)).first;
            rend: &u8 = (&ls).render();
            (&(parser.suffixes)).append<&u8>(rend);
        } else if (&((&f).proto)).variant == FnProtoType#Infix {
            found: bool = false;
            hint: &Expr;
            i: u64 = 0;
            while i < (&hints).len {
                hint_: &Hints = (&hints).get<Hints>(i);
                j: u64 = 0;
                while j < (&(hint_.names)).len {
                  ls: &LexString = ((&(hint_.names)).get<LexString>(j));
                  rend: &u8 = (ls).render();
                  if rend == "prec" {
                      found = true;
                      hint = ((&(hint_.values)).get<Expr>(j));
                      break;
                  };
                  free rend;
                };
                if found {break};
                i++;
            };
            if !found {panic("Expected a prec hint for an infix fn");};
            // if (&(hint.values)).len != 1 {panic("Expected 1 arg to a prec hint");};
            arg: &Expr = hint; // (&(hint.values)).get<Expr>(0);
            if (arg.variant) != ExprType#Number {panic("Expected a number for a prec hint");};
            ls: LexString = ((arg.value) as &NumberExpr).source;
            rend: &u8 = (&ls).render();
            p: u64 = aToI(rend);
            free rend;
            ls = (&((&f).proto)).first;
            rend = (&ls).render();
            (&(parser.binaries)).hmlist_add<&u8, u64>(rend, p);
        };

        f.asTLExpr()
    };
    free next;
    (&e).hints = hints;
    (&e).has_template = has_template;
    (&e).template = template;
    
    parser.lexer.takeWhitespace();
    while (parser.lexer.peekChar() == ';') && (!(parser.lexer.isEof())){
        parser.lexer.takeChar();
        parser.lexer.takeWhitespace();
    };
    e
};

//  }}}


// COMPILER ISH {{{

// INST DECL {{{
enum Instructions = {
  Cast,
  Call,
  Break,
  Return,
  Vardef,
  Builtin,
  IfBranch,
  WhileBranch,
  SubBlockBranch,
  InstantiateTemplated,
};
// BUILTINS (ew) {{{
enum BuiltinInstructions = {
  Store,
  Load,
  IntCmpEQ,
  IntCmpNEQ,
  IntCmpULT,
  IntCmpUGT,
  IntCmpULE,
  IntCmpUGE,
  And,
  Or,
  Xor,
  Not,
  IntSignedRemainder,
  Add,
  Sub,
  Mul,
  IntDiv,
  ArrGEP,
};
// }}}

type Instruction = {
  variant: Instructions,
  value: &u8,
};
// }}}
// TYPES {{{
enum CompilerTypeType = {
  Int,
  Reference,
  Struct,
  Alias,
  Void,
};
// TODO: FUNC
type CompilerType = {
  variant: CompilerTypeType,
  value: &u8,
};
prefix copy(c: CompilerType) : &CompilerType = c.flatCopy<CompilerType>();

type CompilerStructType = {
  names: <LexString> VariableArray,
  types: <CompilerType> VariableArray,
};
type CompilerTemplatedType = {
  types: <CompilerType> VariableArray,
  templated: CompilerType,
};
type CompilerIntType = {
  bitwidth: u64,
  // TODO: signed
};
type CompilerAliasType = {
  name: LexString,
  // TODO: signed
};
prefix copy(c: CompilerAliasType) : &CompilerAliasType = c.flatCopy<CompilerAliasType>();
prefix copy(c: CompilerIntType) : &CompilerIntType = c.flatCopy<CompilerIntType>();
prefix copy(c: CompilerStructType) : &CompilerStructType = c.flatCopy<CompilerStructType>();
overloadable func asCompilerType(c: CompilerIntType) : CompilerType = {
  t: CompilerType;
  (&t).variant = CompilerTypeType#Int;
  (&t).value = (copy c) as &u8;

  t
};
// }}}
// VARIABLE {{{
// TODO: replace with LexString
type Variable = {
    name: &u8,
    number: u64,
    explicit: bool,
    ty_known: bool,
    ty: CompilerType,
    literal: bool,
    none: bool,
};

func variable#none() : Variable = {
  v: Variable;
  (&v).none = true;

  v
};
// }}}

// BLOCK {{{
type Block = {
  //is_toplevel: bool,
  //parent_instr_idx: u64,
  //parent_block_idx: u64,
  // parent_fn_idx: u64,
  instructions: <Instruction> VariableArray,
  retvar: Variable,
  // known_vars: <&u8, CompilerType> HashMap,
  idx: u64,
};
func block#newTl(parent_fn_idx: u64, idx: u64) : Block = {
  b: Block;
  // (&b).is_toplevel = true;
  // (&b).parent_fn_idx = parent_fn_idx;
  (&b).instructions = variablearray#new<Instruction>();
  // (&b).known_vars: hashmap#new();
  (&b).idx = idx;

  b
};

func block#newParented(parent_fn_idx: u64, parent_instr_idx: u64, parent_block_idx: u64, idx: u64) : Block = {
  b: Block;
  // (&b).is_toplevel = false;
  // (&b).parent_fn_idx = parent_fn_idx;
  //(&b).parent_instr_idx = parent_instr_idx;
  //(&b).parent_block_idx = parent_block_idx;
  //(&b).instructions = variablearray#new<Instruction>();
  (&b).idx = idx;

  b
};
// }}}

// FUNCTION {{{
type FunctionArg = {
  name: &u8,
  ty: CompilerType,
};
type Function = {
    blocks: <Block> VariableArray,
    name: &u8,
    args: <FunctionArg> VariableArray,
    has_body: bool,
    retty: CompilerType,
    retvar: Variable,
    idx: u64,
    var_tick: u64,
};

func function#new(name: &u8, args: <FunctionArg> VariableArray, has_body: bool, retty: CompilerType, idx: u64) : Function = {
  f: Function;
  (&f).name = name;
  (&f).args = args;
  (&f).has_body = has_body;
  (&f).var_tick = 0;
  (&f).retty = retty;
  
  if has_body {
    (&f).blocks = variablearray#new<Block>();
    b: Block = block#newTl(idx, 0);
    (&((&f).blocks)).append<Block>(b);
  };

  f
};
// }}}

// LITERALS {{{
enum LiteralType = {
  Number,
  String,
};
type Literal = {
  variant: LiteralType,
  data: &u8,
};
type NumberLiteral = {
    number: u64,
    bitwidth: u64,
};
prefix copy(n: NumberLiteral) : &NumberLiteral = n.flatCopy<NumberLiteral>();
// }}}

// Module {{{
type Module = {
  type_mappings: <&u8, CompilerType> HashMap,
  functions: <&u8, <Function> VariableArray> HashMap,
  enums: <&u8, <&u8> VariableArray> HashMap,
  fn_count: u64,
  // used to name implicits
  literals: <Literal> VariableArray,
};

func module#new() : Module = {
  m: Module;
  (&m).literals = variablearray#new<Literal>();
  (&m).type_mappings = hashmap#new<&u8, CompilerType>();
  (&m).functions = hashmap#new<&u8, <Function> VariableArray>();
  (&m).fn_count = 0;
  m
};

// don't free name
func addFunc(self: &Module, name: &u8, args: <FunctionArg> VariableArray, has_body: bool, retty: CompilerType) : &Function = {
  f: Function = function#new(name, args, has_body, retty, self.fn_count);
  (self.fn_count)++;
  if !((&(self.functions)).hm_contains<&u8, <Function> VariableArray>(name)) {
    (&(self.functions)).hm_add<&u8, <Function> VariableArray>(name, variablearray#new<Function>());
  };
  arr: &<Function> VariableArray = (&(self.functions)).hm_get<&u8, <Function> VariableArray>(name);
  arr.append<Function>(f);
  arr.get<Function>(arr.len - 1)
};
// }}}

// Instructions {{{

// TODO: make work with longer than 1-char brackets
type CallInstruction = {
    is_brack: bool,
    b_first: u8,
    b_last: u8,
    target_fn: Variable,
    args: <Variable> VariableArray,
    output: Variable,
};
prefix copy(c: CallInstruction) : &CallInstruction = c.flatCopy<CallInstruction>();
overloadable func asInstruction(c: CallInstruction) : Instruction = {
    i: Instruction;
    (&i).variant = Instructions#Call;
    (&i).value = (copy c) as &u8;

    i
};

type ReturnInstruction = {
    has_val: bool,
    value: Variable,
};
prefix copy(r: ReturnInstruction) : &ReturnInstruction = r.flatCopy<ReturnInstruction>();
overloadable func asInstruction(r: ReturnInstruction) : Instruction = {
    i: Instruction;
    (&i).variant = Instructions#Return;
    (&i).value = (copy r) as &u8;

    i
};

type IfBranchInstruction = {
    condition: Variable,
    then_idx: u64,
    has_else: bool,
    els_idx: u64,
};
prefix copy(i: IfBranchInstruction) : &IfBranchInstruction = i.flatCopy<IfBranchInstruction>();
overloadable func asInstruction(i_: IfBranchInstruction) : Instruction = {
    i: Instruction;
    (&i).variant = Instructions#IfBranch;
    (&i).value = (copy i_) as &u8;

    i
};

type WhileBranchInstruction = {
    condition: Variable,
    then_idx: u64,
};
prefix copy(w: WhileBranchInstruction) : &WhileBranchInstruction = w.flatCopy<WhileBranchInstruction>();
overloadable func asInstruction(w: WhileBranchInstruction) : Instruction = {
    i: Instruction;
    (&i).variant = Instructions#WhileBranch;
    (&i).value = (copy w) as &u8;

    i
};
type VardefInstruction = {
  name: Variable,
  ty: CompilerType,
};

prefix copy(v: VardefInstruction) : &VardefInstruction = v.flatCopy<VardefInstruction>();
overloadable func asInstruction(v: VardefInstruction) : Instruction = {
    i: Instruction;
    (&i).variant = Instructions#Vardef;
    (&i).value = (copy v) as &u8;

    i
};

type CastInstruction = {
    from: Variable,
    to: Variable,
};
prefix copy(c: CastInstruction) : &CastInstruction = c.flatCopy<CastInstruction>();
overloadable func asInstruction(c: CastInstruction) : Instruction = {
    i: Instruction;
    (&i).variant = Instructions#Cast;
    (&i).value = (copy c) as &u8;

    i
};

type SubBlockBranchInstruction = {
  block_idx: u64,
//   has_retval: bool,
//  retval: Variable,
};
// prefix copy(s: SubBlockBranchInstruction) : &SubBlockBranchInstruction = s.flatCopy<SubBlockBranchInstruction>();
overloadable func asInstruction(s: SubBlockBranchInstruction) : Instruction = {
    i: Instruction;
    (&i).variant = Instructions#SubBlockBranch;
    (&i).value = (s.flatCopy<SubBlockBranchInstruction>()) as &u8;

    i
};

// TODO: shouldn't val be a thingy whatsit identifier/&u8?
type InstantiateTemplatedInstruction = {
  val: Variable,
  args: <CompilerType> VariableArray,
  output: Variable,
};
prefix copy(t: InstantiateTemplatedInstruction) : &InstantiateTemplatedInstruction = t.flatCopy<InstantiateTemplatedInstruction>();
overloadable func asInstruction(t: InstantiateTemplatedInstruction) : Instruction = {
    i: Instruction;
    (&i).variant = Instructions#InstantiateTemplated;
    (&i).value = (copy t) as &u8;

    i
};

// }}}

// Compiler {{{
type Compiler = {
    module: &Module,
    curr_fn: &Function,
    curr_fn_idx: u64,
    curr_block: &Block,
    curr_block_idx: u64,
};

// }}}

// BIG TODO: dedup logic, make a variable#newanon fn!

// TYPES {{{
func compileType(c: &Compiler, t: &TypeExpr) : CompilerType = {
    if t.variant == TypeType#Reference {
        q: CompilerType = c.compileType((t.value) as &TypeExpr);
        ct: CompilerType;
        (&ct).variant = CompilerTypeType#Reference;
        (&ct).value = (copy q) as &u8;
        return ct;
    } else if t.variant == TypeType#Named {
        q: CompilerAliasType;
        (&q).name = (((t.value) as &NamedTypeExpr).name);
        ct: CompilerType;
        // we need to handle special cases like u*
        // TODO: the rest of them / genericify this
        // TODO: tidy up
        name: &u8 = (&((&q).name)).render();
        if name == "u64" {
          (&ct).variant = CompilerTypeType#Int;
          n: CompilerIntType;
          (&n).bitwidth = 64;
          (&ct).value = (copy n) as &u8;
        } else {
          (&ct).variant = CompilerTypeType#Alias;
          (&ct).value = (copy q) as &u8;
        };
        return ct;
    } else if t.variant == TypeType#Struct {
        st: &StructTypeExpr = (t.value) as &StructTypeExpr;
        sta: &<StructVarDef> VariableArray = &(st.types);
        q: CompilerStructType;
        (&q).names = variablearray#new<LexString>();
        (&q).types = variablearray#new<CompilerType>();
        i: u64 = 0;
        while i < sta.len {
            svd: &StructVarDef = sta.get<StructVarDef>(i);
            (&((&q).names)).append<LexString>(svd.name);
            (&((&q).types)).append<CompilerType>(c.compileType(&(svd.type)));
            i++;
        };
        ct: CompilerType;
        (&ct).variant = CompilerTypeType#Struct;
        (&ct).value = (copy q) as &u8;
        return ct;
    };
    panic("UNIMPLEMENTED COMPILETYPE");
    c: CompilerType;
    c
};
// }}}

// COMPILER {{{
func compiler#new(module: &Module) : Compiler = {
    c: Compiler;
    (&c).module = module;

    c
};
// }}}


func compileExpr(c: &Compiler, e: Expr) : Variable;
func compileExprWithBlockHandled(c: &Compiler, e: Expr) : Variable;

// compiling exprs {{{
func compileIdentifierExpr(c: &Compiler, i: IdentifierExpr): Variable = {
    v: Variable;
    (&v).name = (&((&i).source)).render();
    (&v).explicit = true;
    (&v).ty_known = false;
    (&v).none = false;

    v
};

func compileNumberExpr(c: &Compiler, n: NumberExpr) : Variable = {
    l: Literal;
    nl: NumberLiteral;
    r: &u8 = (&((&n).source)).render();
    i: u64 = aToI(r);
    free r;
    (&nl).number = i;
    // TODO: sane default managaent
    (&nl).bitwidth = if (&n).has_bitwidth {
        r: &u8 = (&((&n).bitwidth)).render();
        q: u64 = r.aToI();
        free r;
        q
    } else {64};
    pnl: &NumberLiteral = copy nl;
    (&l).variant = LiteralType#Number;
    (&l).data = pnl as &u8;
    (&(((c.module)).literals)).append<Literal>(l);

    it: CompilerIntType;
    (&it).bitwidth = (&nl).bitwidth;
    t: CompilerType = it.asCompilerType();

    v: Variable;
    (&v).explicit = false;
    (&v).ty_known = true;
    (&v).ty = t;
    (&v).literal = true;
    (&v).none = false;
    (&v).number = ((&(((c.module)).literals)).len) - 1;

    v
};

func compileBlockIntoCurrent(c: &Compiler, b: BlockExpr) : Variable = {
    // TODO: variable breakout
    i: u64 = 0;
    v: Variable;
    while i < (&((&b).exprs)).len {
        v = c.compileExpr(*((&((&b).exprs)).get<Expr>(i)));
        i++
    };

    if (&b).use_last_val {v} else {variable#none()}
};

func compileVardef(c: &Compiler, v: VardefExpr) : Variable = {
    var: Variable;
    (&var).name = (&((&v).source)).render();
    (&var).explicit = true;
    (&var).none = false;
    (&var).ty_known = true;
    (&var).ty = c.compileType(&((&v).ty));

    vdi: VardefInstruction;
    (&vdi).name = var;
    (&vdi).ty = (&var).ty;

    (&(c.curr_block.instructions)).append<Instruction>(vdi.asInstruction());

    var
};

func compileStringExpr(c: &Compiler, s: StringExpr) : Variable = {
    l: Literal;
    (&l).variant = LiteralType#String;
    (&l).data = (&s).value;

    (&(((c.module)).literals)).append<Literal>(l);

    it: CompilerIntType;
    (&it).bitwidth = 8;
    t: CompilerType = it.asCompilerType();
    ptr: CompilerType;
    (&ptr).variant = CompilerTypeType#Reference;
    (&ptr).value = (copy t) as &u8;

    v: Variable;
    (&v).explicit = false;
    (&v).ty_known = true;
    (&v).ty = ptr;
    (&v).literal = true;
    (&v).none = false;
    (&v).number = ((&(((c.module)).literals)).len) - 1;

    v
};

func compileCharExpr(c: &Compiler, ch: CharExpr) : Variable = {
    l: Literal;
    nl: NumberLiteral;
    i: u8 = (&ch).value;
    (&nl).number = @AS("int_z_extend i 64");
    (&nl).bitwidth = 8;
    pnl: &NumberLiteral = copy nl;
    (&l).variant = LiteralType#Number;
    (&l).data = pnl as &u8;
    (&(((c.module)).literals)).append<Literal>(l);

    it: CompilerIntType;
    (&it).bitwidth = 8;
    t: CompilerType = it.asCompilerType();

    v: Variable;
    (&v).explicit = false;
    (&v).ty_known = true;
    (&v).ty = t;
    (&v).literal = true;
    (&v).none = false;
    (&v).number = ((&(((c.module)).literals)).len) - 1;

    v
};

func compileWhileExpr(c: &Compiler, w: WhileExpr) : Variable = {
    wi: WhileBranchInstruction;
    (&wi).condition = c.compileExpr((&w).cond);
    // before add instr
    b: Block = block#newParented(c.curr_fn_idx, (&(c.curr_block.instructions)).len, c.curr_block_idx, (&(c.curr_fn.blocks)).len);
    old_b: &Block = c.curr_block;
    old_b_idx: u64 = c.curr_block_idx;
    (&(c.curr_fn.blocks)).append<Block>(b);

    (&wi).then_idx = (&b).idx;
    
    (&(c.curr_block.instructions)).append<Instruction>(wi.asInstruction());

    c.curr_block = &b;
    c.curr_block_idx = (&b).idx;

    c.compileExprWithBlockHandled((&w).then);

    // return to old block
    c.curr_block = old_b;
    c.curr_block_idx = old_b_idx;

    
    variable#none()
};

func compileIfExpr(c: &Compiler, i: IfExpr) : Variable = {
    // BIG TODO: PHIS
    ii: IfBranchInstruction;
    (&ii).has_else = (&i).has_else;
    (&ii).condition = c.compileExpr((&i).cond);
    // before add instr
    b: Block = block#newParented(c.curr_fn_idx, (&(c.curr_block.instructions)).len, c.curr_block_idx, (&(c.curr_fn.blocks)).len);
    
    old_b: &Block = c.curr_block;
    old_b_idx: u64 = c.curr_block_idx;
    (&(c.curr_fn.blocks)).append<Block>(b);

    (&ii).then_idx = (&b).idx;

    c.curr_block_idx = (&b).idx;
    

    c.curr_block = (&(c.curr_fn.blocks)).get<Block>((&(c.curr_fn.blocks)).len - 1);

    c.compileExprWithBlockHandled((&i).then);

    els_b: Block;
    if (&ii).has_else {
        els_b = block#newParented(c.curr_fn_idx, (&(c.curr_block.instructions)).len, c.curr_block_idx, (&(c.curr_fn.blocks)).len + 1);
        (&ii).els_idx = (&els_b).idx;

        c.curr_block_idx = (&els_b).idx;
        (&(c.curr_fn.blocks)).append<Block>(els_b);
        c.curr_block = (&(c.curr_fn.blocks)).get<Block>((&(c.curr_fn.blocks)).len - 1);


        c.compileExprWithBlockHandled((&i).els);
    };


    // return to old block
    c.curr_block = old_b;
    c.curr_block_idx = old_b_idx;


    (&(c.curr_block.instructions)).append<Instruction>(ii.asInstruction());

    
    variable#none()
};

func compileReturnExpr(c: &Compiler, r: ReturnExpr) : Variable = {
    ri: ReturnInstruction;
    (&ri).has_val = (&r).has_val;
    if (&r).has_val {
        (&ri).value = c.compileExpr((&r).val);
    };

    (&((c.curr_block).instructions)).append<Instruction>((ri).asInstruction());

    variable#none()
};

func compileCastExpr(c: &Compiler, r: CastExpr) : Variable = {
    from: Variable = c.compileExpr((&r).val);
    to: Variable;
    (&to).explicit = false;
    (&to).ty_known = true;
    (&to).ty = c.compileType(&((&r).ty));
    (&to).literal = false;
    (&to).none = false;
    (&to).number = c.curr_fn.var_tick;
    (c.curr_fn.var_tick) += 1;
    ci: CastInstruction;
    (&ci).from = from;
    (&ci).to = to;

    (&((c.curr_block).instructions)).append<Instruction>((ci).asInstruction());

    to
};

func compilePrefixCallExpr(c: &Compiler, p: PrefixCallExpr) : Variable = {
    target_fn: Variable = c.compileIdentifierExpr((&p).prefix);
    args: <Variable> VariableArray = variablearray#new<Variable>();
    (&args).append<Variable>(c.compileExpr((&p).val));

    to: Variable;
    (&to).explicit = false;
    (&to).ty_known = false;
    (&to).literal = false;
    (&to).none = false;
    (&to).number = c.curr_fn.var_tick;
    (c.curr_fn.var_tick) += 1;

    ci: CallInstruction;
    (&ci).is_brack = false;
    (&ci).args = args;
    (&ci).target_fn = target_fn;
    (&ci).output = to;

    (&((c.curr_block).instructions)).append<Instruction>((ci).asInstruction());

    to
};

func compileSuffixCallExpr(c: &Compiler, s: SuffixCallExpr) : Variable = {
    target_fn: Variable = c.compileIdentifierExpr((&s).suffix);
    args: <Variable> VariableArray = variablearray#new<Variable>();
    (&args).append<Variable>(c.compileExpr((&s).val));

    to: Variable;
    (&to).explicit = false;
    (&to).ty_known = false;
    (&to).literal = false;
    (&to).none = false;
    (&to).number = c.curr_fn.var_tick;
    (c.curr_fn.var_tick) += 1;

    ci: CallInstruction;
    (&ci).is_brack = false;
    (&ci).args = args;
    (&ci).target_fn = target_fn;
    (&ci).output = to;

    (&((c.curr_block).instructions)).append<Instruction>((ci).asInstruction());

    to
};

func compileBinaryExpr(c: &Compiler, b: BinaryExpr) : Variable = {
    target_fn: Variable = c.compileIdentifierExpr((&b).op);
    args: <Variable> VariableArray = variablearray#new<Variable>();
    (&args).append<Variable>(c.compileExpr((&b).lhs));
    (&args).append<Variable>(c.compileExpr((&b).rhs));

    to: Variable;
    (&to).explicit = false;
    (&to).ty_known = false;
    (&to).literal = false;
    (&to).none = false;
    (&to).number = c.curr_fn.var_tick;
    (c.curr_fn.var_tick) += 1;

    ci: CallInstruction;
    (&ci).is_brack = false;
    (&ci).args = args;
    (&ci).target_fn = target_fn;
    (&ci).output = to;

    (&((c.curr_block).instructions)).append<Instruction>((ci).asInstruction());

    to
};

func compilePostfixBracketsExpr(c: &Compiler, p: PostfixBracketsExpr) : Variable = {
    target_fn: Variable = c.compileExpr((&p).val);
    args: <Variable> VariableArray = variablearray#new<Variable>();
    i: u64 = 0;
    while i < (&((&p).args)).len {
        (&args).append<Variable>(c.compileExpr(*((&((&p).args)).get<Expr>(i))));
        i++;
    };

    to: Variable;
    (&to).explicit = false;
    (&to).ty_known = false;
    (&to).literal = false;
    (&to).none = false;
    (&to).number = c.curr_fn.var_tick;
    (c.curr_fn.var_tick) += 1;

    ci: CallInstruction;
    (&ci).is_brack = true;
    (&ci).args = args;
    (&ci).target_fn = target_fn;
    (&ci).output = to;
    (&ci).b_first = (&p).brack_first;
    (&ci).b_last = (&p).brack_last;

    (&((c.curr_block).instructions)).append<Instruction>((ci).asInstruction());

    to
};

func compileTemplatedExpr(c: &Compiler, t: TemplatedExpr) : Variable = {
    val: Variable = c.compileExpr((&t).val);
    args: <CompilerType> VariableArray = variablearray#new<CompilerType>();
    i: u64 = 0;
    while i < (&((&t).types)).len {
        (&args).append<CompilerType>(c.compileType(((&((&t).types)).get<TypeExpr>(i))));
        i++;
    };

    to: Variable;
    (&to).explicit = false;
    (&to).ty_known = false;
    (&to).literal = false;
    (&to).none = false;
    (&to).number = c.curr_fn.var_tick;
    (c.curr_fn.var_tick) += 1;

    iti: InstantiateTemplatedInstruction;
    (&iti).val = val;
    (&iti).args = args;
    (&iti).output = to;

    (&((c.curr_block).instructions)).append<Instruction>((iti).asInstruction());

  to
};

func compileExprWithBlockHandled(c: &Compiler, e: Expr) : Variable = {
    if (&e).variant == ExprType#Number {
        c.compileNumberExpr(*(((&e).value) as &NumberExpr))
    } else if (&e).variant == ExprType#Identifier {
        c.compileIdentifierExpr(*(((&e).value) as &IdentifierExpr))
    } else if (&e).variant == ExprType#Block {
        c.compileBlockIntoCurrent(*(((&e).value) as &BlockExpr))
    } else if (&e).variant == ExprType#String {
        c.compileStringExpr(*(((&e).value) as &StringExpr))
    } else if (&e).variant == ExprType#If {
        c.compileIfExpr(*(((&e).value) as &IfExpr))
    } else if (&e).variant == ExprType#While {
        c.compileWhileExpr(*(((&e).value) as &WhileExpr))
    } else if (&e).variant == ExprType#Vardef {
        c.compileVardef(*(((&e).value) as &VardefExpr))
    } else if (&e).variant == ExprType#Return {
        c.compileReturnExpr(*(((&e).value) as &ReturnExpr))
    } else if (&e).variant == ExprType#Cast {
        c.compileCastExpr(*(((&e).value) as &CastExpr))
    } else if (&e).variant == ExprType#CDef {
        panic("UNIMPL COMPILE CDEF");
        v: Variable;
        v
    } else if (&e).variant == ExprType#PostfixBrackets {
        c.compilePostfixBracketsExpr(*(((&e).value) as &PostfixBracketsExpr))
    } else if (&e).variant == ExprType#PrefixCall {
        c.compilePrefixCallExpr(*(((&e).value) as &PrefixCallExpr))
    } else if (&e).variant == ExprType#SuffixCall {
        c.compileSuffixCallExpr(*(((&e).value) as &SuffixCallExpr))
    } else if (&e).variant == ExprType#TemplatedExpr {
        c.compileTemplatedExpr(*(((&e).value) as &TemplatedExpr))
    } else if (&e).variant == ExprType#Binary {
        c.compileBinaryExpr(*(((&e).value) as &BinaryExpr))
    } else if (&e).variant == ExprType#Char {
        c.compileCharExpr(*(((&e).value) as &CharExpr))
    } else {
        panic("wud, compile expr not impl");
        v: Variable;
        v
    }
};
// }}}
// compileExpr {{{
func compileExpr(c: &Compiler, e: Expr) : Variable = {
    if (&e).variant == ExprType#Block {
        sbb: SubBlockBranchInstruction;
        // before add instr
        b: Block = block#newParented(c.curr_fn_idx, (&(c.curr_block.instructions)).len, c.curr_block_idx, (&(c.curr_fn.blocks)).len);
        old_b: &Block = c.curr_block;
        old_b_idx: u64 = c.curr_block_idx;
        (&(c.curr_fn.blocks)).append<Block>(b);

        (&sbb).block_idx = (&b).idx;
        
        (&(c.curr_block.instructions)).append<Instruction>(sbb.asInstruction());

        c.curr_block = &b;
        c.curr_block_idx = (&b).idx;

        v: Variable = c.compileExprWithBlockHandled(e);

        // return to old block
        c.curr_block = old_b;
        c.curr_block_idx = old_b_idx;

        v
    } else {
        c.compileExprWithBlockHandled(e)
    }
};
// }}}
// compileFn {{{
func compileFunctionProto(c: &Compiler, f: FnDefTLExpr) : &Function = {
  proto: &FnProto = &((&f).proto);
  namep: &u8 = (&(proto.first)).render();
  name: &u8 = if proto.variant == FnProtoType#Brackets {
    v: <u8> VariableArray = va_from_str(namep);
    (&v).append<u8>(' ');
    free(namep);
    namep = (&(proto.last)).render();
    (&v).append_str(namep);
    free(namep);
    // TODO: should I drop v?
    (&v).str_from_va()
  } else {namep};
  // don't free name
  args: <FunctionArg> VariableArray = variablearray#new<FunctionArg>();
  i: u64 = 0;
  while i < (&(proto.args)).len {
    arg: &VardefExpr = (&(proto.args)).get<VardefExpr>(i);
    fna: FunctionArg;
    (&fna).ty = c.compileType(&(arg.ty));
    (&fna).name = (&((&(arg.var)).source)).render();
    (&args).append<FunctionArg>(fna);
  };
  retty: CompilerType = if proto.has_retty {
    c.compileType(&(proto.retty))
  } else {
    ct: CompilerType;
    (&ct).variant = CompilerTypeType#Void;
    ct
  };
  idx: u64 = ((c.module)).fn_count;
  (((c.module)).fn_count)++;

  if proto.macro {
    panic("compileFunction macro=true not implemented");  
  };

  fnc: Function = function#new(name, args, (&f).has_body, retty, idx);
    
  fnpt: &Function = if (&(((c.module)).functions)).hm_contains<&u8, <Function> VariableArray>(name) {
    v: &<Function> VariableArray = (&(((c.module)).functions)).hm_get<&u8, <Function> VariableArray>(name);
    (v).append<Function>(fnc);
    (v).get<Function>(((v).len) - 1)
  } else {
    v: <Function> VariableArray = variablearray#new<Function>();
    (&v).append<Function>(fnc);
    fn: &Function = (&v).get<Function>(((&v).len) - 1);
    (&(((c.module)).functions)).hm_add<&u8, <Function> VariableArray>(name, v);
    fn
  };

  fnpt
};

func compileFunction(c: &Compiler, fd: FnDefTLExpr) : &Function = {
  f: &Function = c.compileFunctionProto(fd);
  f.retvar = variable#none();
  if (&(fd)).has_body {
    c.curr_fn = f;
    c.curr_fn_idx = (((c.module)).fn_count) - 1;
    c.curr_block = (&(f.blocks)).get<Block>(0);
    c.curr_block_idx = 0;

    f.retvar =  c.compileExpr(((&(fd)).body));
  };

  f;
};
// }}}
// compileEnum {{{
func compileEnum(c: &Compiler, e: EnumTLExpr) = {

};
// }}}
// }}}

// to LLIR i guess?? {{{

// LlvmBlock {{{
type LlvmBlock = {
  instrs: <<u8> VariableArray> VariableArray
};
func add_instr(b: &LlvmBlock, i: <u8> VariableArray) = {
  (&(b.instrs)).append<<u8> VariableArray>(i)
};
func llvmblock#new() : LlvmBlock = {
  l: LlvmBlock;
  (&l).instrs = variablearray#new<<u8> VariableArray>();

  l
};// }}}
// LlvmFunction {{{
type LlvmFunction = {
  entry_block: &LlvmBlock,
  blocks: <&u8, LlvmBlock> HashMap,
};
// }}}


// LlvmModule {{{
type LlvmModule = {
  functions: <LlvmFunction> VariableArray,
  curr_fn: &LlvmFunction,
  curr_block: &LlvmBlock,
  iblock_inc: u64,
  break_to: <u8> VariableArray,
  from_fn: &Function,
  parent_mod: &Module,
  // TODO: globals literals etc etc
};
func llvmmodule#new(mod: &Module) : LlvmModule = {
  l: LlvmModule;
  lp: &LlvmModule = &l;
  lp.functions = variablearray#new<LlvmFunction>();
  lp.iblock_inc = 0;
  lp.parent_mod = mod;

  l
};
// }}}
// fwd-defs {{{
func llvmCompileInstruction(mod: &LlvmModule, i: &Instruction) : <u8> VariableArray = {
  panic("unimplwed");
  va_from_str("no");
};
// }}}
// llvmCompileType {{{
func llvmCompileType(ty: &CompilerType) : <u8> VariableArray = {
  v: <u8> VariableArray;
  if ty.variant == CompilerTypeType#Int {
    c: &CompilerIntType = (ty.value) as &CompilerIntType;
    v = va_from_str("i");
    (&v).append_str(iToA_b10(c.bitwidth));
  } else if ty.variant == CompilerTypeType#Reference {
    v = llvmCompileType((ty.value) as &CompilerType);
    (&v).append_str("*");
  } else if ty.variant == CompilerTypeType#Struct {
    // TODO: refactor to use consts when they happen
    v = va_from_str("{ ");
    // vp: &<u8>VariableArray = &v;
    v3: <u8> VariableArray = va_from_str(", ");
    v4: <u8> VariableArray = va_from_str(" }");
    i: u64 = 0;
    c: &CompilerStructType = (ty.value) as &CompilerStructType;
    while i < (&(c.types)).len {
      v2: <u8> VariableArray = llvmCompileType((&(c.types)).get<CompilerType>(i));
      (&v).append_va<u8>(&v2);
      drop<u8>(v2);
      i++;
      if i < (&(c.types)).len {
        (&v).append_va<u8>(&v3);
      }
    };
    drop<u8>(v3);
    (&v).append_va<u8>(&v4);
    drop<u8>(v4);
  } else {
      tyv: u64 = (ty.variant) as u64;
      printf(iToA_b10(tyv));
      panic("\nunknown compiler type for llvmCompileType")
  };

  v
};
// }}}
// compile block {{{
// compiles into, does not make a new block.
func llvmCompileBlock(mod: &LlvmModule, bidx: u64) = {
  // TODO: ensure these are variable names, not instructions
  block: &Block = (&(mod.from_fn.blocks)).get<Block>(bidx);
  instrs: & <Instruction> VariableArray = &(block.instructions);
  i: u64 = 0;
  last: <u8> VariableArray = variablearray#new<u8>();
  while i < instrs.len {
    last = mod.llvmCompileInstruction(instrs.get<Instruction>(i));
    i++;
  };
  // no need for returns since we just assert that we have created the variable we are going to use later
};
// }}}


// Instructions {{{
// compile variable {{{
type LlvmCompileVariableResult = {
  name: <u8> VariableArray,
  ty: <u8> VariableArray,
};
prefix drop(t: LlvmCompileVariableResult) = {
  drop<u8>((&t).name);
  drop<u8>((&t).ty);
};

func llvmCompileVariable(mod: &LlvmModule, v: &Variable) : LlvmCompileVariableResult = {
    r: LlvmCompileVariableResult;
    if v.literal {
        l: &Literal = (&(mod.parent_mod.literals)).get<Literal>(v.number);
        if l.variant == LiteralType#Number {
          n: &NumberLiteral = (l.data) as &NumberLiteral;
          s: &u8 = iToA_b10(n.number);
          (&r).name = va_from_str(s);
          free(s);
          s = iToA_b10(n.bitwidth);
          (&r).ty = va_from_str("i");
          (&((&r).ty)).append_str(s);
          free(s);

          return r;
        } else {
        
        }
    } else {

    };
    // Functions are first-class <3
    // TODO: sanitization of LLVM IR-compatible names (like == needs to be "==")
    // Also add % or @ as required (local v global I think?)
    panic("unimplW");
    o: LlvmCompileVariableResult;
    o
};
// }}}
// compile call {{{
func llvmCompileCallInstruction(mod: &LlvmModule, c: &CallInstruction) : <u8> VariableArray = {
  // syntax: `call <retty> @name(argtype %name, ...)`
  // (&(mod.functions)).hm_get(&u8 name) returns a vararray of overloadabels
  v: <u8> VariableArray = va_from_str("call ");
  // TODO: overloadables
  // specifically, check if variable is named and then the vararray from module is longer than 1
  // if so, don't compile the variable, pick out the name, append llvmcompiled-type, and use that instead <3
  // remember to sanitize! wrap in quotes :3
  // no i will not explain the :3 it just feels right
  // TODO: bracket functions
  fn: LlvmCompileVariableResult = mod.llvmCompileVariable(&(c.target_fn));
  (&v).append_va<u8>(&((&fn).ty));
  (&v).append_str(" ");
  (&v).append_va<u8>(&((&fn).name));
  (&v).append<u8>('(');
  drop fn;
  args: &<Variable> VariableArray = &(c.args);
  i: u64 = 0;
  while i < args.len {
    arg: LlvmCompileVariableResult = mod.llvmCompileVariable(args.get<Variable>(i));
    (&v).append_va<u8>(&((&arg).ty));
    (&v).append<u8>(' ');
    (&v).append_va<u8>(&((&arg).name));
    i++;
    if i < args.len {
      (&v).append_str(", ");
    };
    drop arg;
  };
  (&v).append<u8>(')');

  v
};
// }}}
// compile ret {{{
func llvmCompileReturnInstruction(mod: &LlvmModule, r: &ReturnInstruction) : <u8> VariableArray = {
  v: <u8> VariableArray = va_from_str("ret ");
  if !(r.has_val) {
    (&v).append_str("void");
    return v
  };

  val: LlvmCompileVariableResult = mod.llvmCompileVariable(&(r.value));
  (&v).append_va<u8>(&((&val).ty));
  (&v).append<u8>(' ');
  (&v).append_va<u8>(&((&val).name));

  drop val;

  v
};
// }}}
// compile if {{{
func llvmCompileIfBranchInstruction(mod: &LlvmModule, i: &IfBranchInstruction) : <u8> VariableArray = {
  cond: LlvmCompileVariableResult = mod.llvmCompileVariable(&(i.condition));
  ty_name: &u8 = (&((&cond).ty)).str_from_va();
  if !(ty_name == "i1") {
    printf("Error compiling to LLVM: `");
    // really we should free it but we panicking so who cares
    printf((&((&cond).name)).str_from_va());
    printf("` as an if condition is not an i1, but rather a `");
    printf((&((&cond).ty)).str_from_va());
    printf("`\n");
    panic();
  };
  free(ty_name);
  // TODO: % in front of names
  cont_name: <u8> VariableArray = va_from_str("ifcont_");
  j: &u8 = iToA_b10(mod.iblock_inc);
  (mod.iblock_inc)++;
  (&cont_name).append_str(j);
  free(j);
  v: <u8> VariableArray = va_from_str("br i1 ");
  (&v).append_va<u8>(&((&cond).name));
  (&v).append_str(", label %");
  // it's all indexes
  ib_name: &u8 = iToA_b10(i.then_idx);
  (&v).append_str(ib_name);

  (&v).append_str(", label %");

  eb_name: &u8;
  if i.has_else {
    eb_name = iToA_b10(i.els_idx);
    (&v).append_str(eb_name);
  } else {
    (&v).append_va<u8>(&cont_name);
  };
  curr_block: &LlvmBlock = mod.curr_block;
  curr_block.add_instr(v);

  resume_instr: <u8> VariableArray = va_from_str("br label %");
  (&resume_instr).append_va<u8>(&cont_name);

  // compile the if-block
  iblock: LlvmBlock = llvmblock#new();
  mod.curr_block = (&(mod.curr_fn.blocks)).hm_add<&u8, LlvmBlock>(ib_name, iblock);
  mod.llvmCompileBlock(i.then_idx);
  mod.curr_block.add_instr(resume_instr);

  // maybe the else block
  if i.has_else {
    eblock: LlvmBlock = llvmblock#new();
    mod.curr_block = (&(mod.curr_fn.blocks)).hm_add<&u8, LlvmBlock>(eb_name, eblock);
    mod.llvmCompileBlock(i.els_idx);
    mod.curr_block.add_instr(resume_instr);
  };

  cblock: LlvmBlock = llvmblock#new();
  mod.curr_block = (&(mod.curr_fn.blocks)).hm_add<&u8, LlvmBlock>((&cont_name).str_from_va(), cblock);

  // BIG TODO: Phi nodes
  // garbaging the returns
  v
};
// }}}
// compile while {{{
func llvmCompileWhileBranchInstruction(mod: &LlvmModule, w: &WhileBranchInstruction) : <u8> VariableArray = {
  cond: LlvmCompileVariableResult = mod.llvmCompileVariable(&(w.condition));
  ty_name: &u8 = (&((&cond).ty)).str_from_va();
  if !(ty_name == "i1") {
    printf("Error compiling to LLVM: `");
    // really we should free it but we panicking so who cares
    printf((&((&cond).name)).str_from_va());
    printf("` as a while condition is not an i1, but rather a `");
    printf((&((&cond).ty)).str_from_va());
    printf("`\n");
    panic();
  };
  free(ty_name);
  // TODO: % in front of names
  cont_name: <u8> VariableArray = va_from_str("whilecont_");
  j: &u8 = iToA_b10(mod.iblock_inc);
  (mod.iblock_inc)++;
  (&cont_name).append_str(j);
  free(j);

  cond_name: <u8> VariableArray = va_from_str("whilecond_");
  j = iToA_b10(mod.iblock_inc);
  (mod.iblock_inc)++;
  (&cond_name).append_str(j);
  free(j);

  condi: <u8> VariableArray = va_from_str("br label %");
  (&condi).append_va<u8>(&cond_name);
  mod.curr_block.add_instr(condi);

  v: <u8> VariableArray = va_from_str("br i1 ");
  (&v).append_va<u8>(&((&cond).name));
  (&v).append_str(", label %");
  // it's all indexes
  ib_name: &u8 = iToA_b10(w.then_idx);
  (&v).append_str(ib_name);

  (&v).append_str(", label %");

  (&v).append_va<u8>(&cont_name);

  condblock: LlvmBlock = llvmblock#new();
  condblockp: &LlvmBlock = (&(mod.curr_fn.blocks)).hm_add<&u8, LlvmBlock>((&cond_name).str_from_va(), condblock);

  condblockp.add_instr(v);

  resume_instr: <u8> VariableArray = va_from_str("br label %");
  (&resume_instr).append_va<u8>(&cont_name);

  // set up breaks
  old_bt: <u8> VariableArray = mod.break_to;
  mod.break_to = cont_name;

  // compile the if-block
  iblock: LlvmBlock = llvmblock#new();
  mod.curr_block = (&(mod.curr_fn.blocks)).hm_add<&u8, LlvmBlock>(ib_name, iblock);
  mod.llvmCompileBlock(w.then_idx);
  mod.curr_block.add_instr(resume_instr);
  
  mod.break_to = old_bt;

  cblock: LlvmBlock = llvmblock#new();
  mod.curr_block = (&(mod.curr_fn.blocks)).hm_add<&u8, LlvmBlock>((&cont_name).str_from_va(), cblock);
  
  // maybe empty vararrays shouldn't be used
  // like, we could have an Option type or smth
  variablearray#new<u8>()
};
// }}}
// compile subblockbranch {{{
func llvmCompileSubBlockBranchInstruction(mod: &LlvmModule, s: &SubBlockBranchInstruction) : <u8> VariableArray = {
  // just realised all the rest is a bit extra lol
  // we can just compile them into the current block, and not waste br-s
  mod.llvmCompileBlock(s.block_idx);
  // TODO: fix blocks and storing their return values
  // need to add a retval field to SubBBranchInst
  variablearray#new<u8>()
/*
  resb_name: <u8> VariableArray = va_from_str("sbb_resume_");
  j: &u8 = iToA_b10(mod.iblock_inc);
  (mod.iblock_inc)++;
  (&resb_name).append_str(j);
  free(j);

  k: &u8 = iToA_b10(mod.iblock_inc);
  sbb_name: <u8> VariableArray = va_from_str(k);
  (mod.iblock_inc)++;
  free(k);

  br_instr: <u8> VariableArray = va_from_str("br label %");
  (&br_instr).append_va<u8>(&sbb_name);

  mod.curr_block.add_instr(br_instr);

  sblock: LlvmBlock = llvmblock#new();
  mod.curr_block = (&(mod.curr_fn.blocks)).hmlist_add<&u8, LlvmBlock>((&sbb_name).str_from_va(), sblock);
  retval: <u8> VariableArray = mod.llvmCompileBlock(s.block_idx);

  resume_instr: <u8> VariableArray = va_from_str("br label %");
  (&resume_instr).append_va<u8>(&resb_name);

  mod.curr_block.add_instr(resume_instr);


  resblock: LlvmBlock = llvmblock#new();
*/
};
// }}}
// compile cast {{{
// TODO: clarify: does the CastInstr expect the name of .to to be used?
func llvmCompileCastInstruction(mod: &LlvmModule, c: &CastInstruction) : <u8> VariableArray = {
  v: <u8> VariableArray = va_from_str("bitcast ");
  r: LlvmCompileVariableResult = mod.llvmCompileVariable(&(c.from));
  (&v).append_va<u8>(&((&r).ty));
  (&v).append<u8>(' ');
  (&v).append_va<u8>(&((&r).name));
  (&v).append_str(" to ");
  t: LlvmCompileVariableResult = mod.llvmCompileVariable(&(c.from));
  (&v).append_va<u8>(&((&t).ty));

  drop r;
  drop t;

  v
};
// }}}
// compile vardef {{{
func llvmCompileVardefInstruction(mod: &LlvmModule, vdi: &VardefInstruction) : <u8> VariableArray = {
  v: <u8> VariableArray = va_from_str("%");
  (&v).append_str(&(vdi.name).name);
  (&v).append_str(" = alloca ");
  ct: <u8> VariableArray = llvmCompileType(&(vdi.ty));
  (&v).append_va<u8>(&ct);
  drop<u8>(ct);

  mod.curr_fn.entry_block.add_instr(v);

  va_from_str(&(vdi.name).name)
};
// }}}
// compile break {{{
func llvmCompileBreak(mod: &LlvmModule) : <u8> VariableArray = {
  v: <u8> VariableArray = va_from_str("br label %");
  (&v).append_va<u8>(&(mod.break_to));
  mod.curr_block.add_instr(v);

  variablearray#new<u8>()
};
// }}}
// }}}

// compile function, please help {{{
func llvmCompileFunction(mod: &LlvmModule, fn: &Function) : <<u8> VariableArray> VariableArray = {
  fn_text: <u8> VariableArray;
  if !(fn.has_body) {
    fn_text = va_from_str("declare ");
  } else {
    fn_text = va_from_str("define ");
  };
  llct: <u8> VariableArray = llvmCompileType(&(fn.retty));
  (&fn_text).append_va<u8>(&llct);
  // drop<u8>(llct);
  (&fn_text).append_str(" @\"");
  (&fn_text).append_str(fn.name);
  (&fn_text).append_str("\"");
  // TODO: should we add the retty to it
  fn_args: <u8> VariableArray = va_from_str("(");
  args: &<FunctionArg> VariableArray = &(fn.args);
  i: u64 = 0;
  while i < args.len {
    ct: <u8> VariableArray = llvmCompileType(&((args.get<FunctionArg>(i)).ty));
    (&fn_text).append_va<u8>(&ct);

    (&fn_args).append_va<u8>(&ct);
    // drop<u8>(ct);
    (&fn_args).append_str(" %");
    (&fn_args).append_str((args.get<FunctionArg>(i)).name);
    i++;
    if i < args.len {
      (&fn_args).append_str(", ")
    }
  };
  (&fn_args).append_str(")");
  (&fn_text).append_va<u8>(&fn_args);
  (&fn_text).append_str(" {");
  // GOT HERE, need to rework (implement) block return values to proceed since functions need to return???
  whole: <<u8> VariableArray> VariableArray = variablearray#new<<u8> VariableArray>();
  (&whole).append<<u8> VariableArray>(fn_text);
  if !(fn.has_body) {
    return whole;
  };
  // le fn
  lfn: LlvmFunction;
  (&lfn).blocks = hashmap#new<&u8, LlvmBlock>();
  // le blocks
  entry_block: LlvmBlock = llvmblock#new();
  (&((&lfn).blocks)).hm_add<&u8, LlvmBlock>("fn_entry", entry_block);
  entry_pt: &LlvmBlock = (&((&lfn).blocks)).hm_get<&u8, LlvmBlock>("fn_entry");
  (&lfn).entry_block = entry_pt;
  mod.curr_fn = &lfn;
  mod.curr_block = entry_pt;
  mod.from_fn = fn;

  mod.llvmCompileBlock(0);

  // okay okay now we need to do retvals
  // the current block is the final
  // ret <variable>
  lcvr: LlvmCompileVariableResult = mod.llvmCompileVariable(&(fn.retvar));
  rinst: <u8> VariableArray = va_from_str("ret ");
  (&rinst).append_va<u8>(&((&(lcvr)).ty));
  (&rinst).append<u8>(' ');
  (&rinst).append_va<u8>(&((&(lcvr)).name));
  mod.curr_block.add_instr(rinst);

  // functionally done
  // just put it all back together

  i: u64 = 0;
  keys: <&u8> VariableArray = (&((&lfn).blocks)).hm_keys<&u8, LlvmBlock>();
  while i < (&keys).len {
    // ok output block name
    block_name: &u8 = *((&keys).get<&u8>(i));
    block_va: <u8> VariableArray = va_from_str(block_name);
    (&block_va).append<u8>(':');
    (&whole).append<<u8> VariableArray>(block_va);
    // ok now get the block
    block: &LlvmBlock = (&((&lfn).blocks)).hm_get<&u8, LlvmBlock>(block_name);
    instrs: &<<u8> VariableArray> VariableArray = &(block.instrs);
    j: u64 = 0;
    while j < instrs.len {
      inst: <u8> VariableArray = va_from_str("  ");
      (&inst).append_va<u8>(instrs.get<<u8> VariableArray>(j));
      (&whole).append<<u8> VariableArray>(inst);
      j++;
    };
    i++;
  };
  (&whole).append<<u8> VariableArray>((va_from_str("}")));
  whole
};
// }}}

func llvmCompile(mod: &LlvmModule) : <<u8> VariableArray> VariableArray = {
  // TODO: literals
  // TODO: iter over type_mappings, enums, literals????
  fns: <& <Function> VariableArray> VariableArray = (&(mod.parent_mod.functions)).hm_vals<&u8, <Function> VariableArray>();
  i: u64 = 0;
  while i < (&fns).len {
    j: u64 = 0;
    fnsfns : & <Function> VariableArray = *((&fns).get<&<Function>VariableArray>(i));
    while j < fnsfns.len {
      result: <<u8> VariableArray> VariableArray = mod.llvmCompileFunction(fnsfns.get<Function>(j));
      k: u64 = 0;
      while k < (&result).len {
        s: &u8 = (((&result).get<<u8> VariableArray>(k))).str_from_va();
        printf(s);
        printf("\n");
        free(s);
        k++;
      };
      j++
    };
    i++;
  };
  v: <<u8> VariableArray> VariableArray;
  v
};

// }}}

// MAIN {{{


func readFile(name: &u8) : &u8;
func cinit();

func main() : u64 = {
    cinit();

    /* h: HashMap<&u8, &u8> = hashmap#new<&u8, &u8>();
    (&h).hm_add<&u8, &u8>("key", "value");
    printf(*((&h).hm_get<&u8, &u8>("key"))); */

    // code: &u8 = "overloadable brackets pqr rps(s: u648) : p65 = {a;};";
    code: &u8 = readFile("./test.silver");
    lexer: &Lexer = &lexer#new(code);
    parser: &Parser = &parser#new(lexer);
    m: Module = module#new();
    c: Compiler = compiler#new(&m);
    while !(parser.lexer.isEof()) {
      e: TLExpr = parser.parseTLExpr();
      // debugTLExpr(&e);
      // TODO: compileTLTypedef
      if (&e).variant == TLExprType#Function {
        // it just adds it to the compipler
        (&c).compileFunction(*(((&e).value) as &FnDefTLExpr));
      }
      // TODO: all the rest
    };
    printf("\n");
    lm: LlvmModule = llvmmodule#new(&m);
    (&lm).llvmCompile();
    exit(0);
    0
};


// }}}
