// EXTERNS {{{

func malloc(bytes: u64) : &u8;
func realloc(data: &u8, bytes: u64) : &u8;
func strlen(str: &u8) : u64;
prefix free(data: &u8);
func strcpy(dest: &u8, src: &u8);
func strncpy(dest: &u8, src: &u8, len: u64);
func memcpy(dest: &u8, src: &u8, len: u64);
func strcmp(a: &u8, b: &u8) : u64;
func printf(str: &u8);
/* func printf(str: &u8, val: u64); */
/* func printf(str: &u8) = printf(str, 0); */
func putchar(char: u8);
func exit(code: u64);
func pow(base: u64, power: u64): u64;

// little extern thing to help me debug
// cuz i cant be asked to write it here
// func print_addr(addr: &u8);

// }}}


// SYSTEM {{{

#prec 25;
infix ==(a: u64, b: u64) : bool = @AS("int_cmp_eq a b");

#prec 25;
infix !=(a: u64, b: u64) : bool = @AS("int_cmp_neq a b");

#prec 30;
infix <(a: u64, b: u64) : bool = @AS("int_cmp_ult a b");

#prec 30;
infix >(a: u64, b: u64) : bool = @AS("int_cmp_ugt a b");

#prec 30;
infix <=(a: u64, b: u64) : bool = @AS("int_cmp_ule a b");

#prec 30;
infix >=(a: u64, b: u64) : bool = @AS("int_cmp_uge a b");

#prec 20;
infix &&(a: u64, b: u64) : u64 = @AS("int_and a b");

#prec 20;
infix ||(a: u64, b: u64) : u64 = @AS("int_or a b");

#prec 25;
infix ==(a: u8, b: u8) : bool = @AS("int_cmp_eq a b");

#prec 25;
infix !=(a: u8, b: u8) : bool = @AS("int_cmp_neq a b");

#prec 30;
infix <(a: u8, b: u8) : bool = @AS("int_cmp_ult a b");

#prec 30;
infix >(a: u8, b: u8) : bool = @AS("int_cmp_ugt a b");

#prec 30;
infix <=(a: u8, b: u8) : bool = @AS("int_cmp_ule a b");

#prec 30;
infix >=(a: u8, b: u8) : bool = @AS("int_cmp_uge a b");

#prec 20;
infix &&(a: u8, b: u8) : u8 = @AS("int_and a b");

#prec 20;
infix ||(a: u8, b: u8) : u8 = @AS("int_or a b");

#prec 20;
infix &&(a: bool, b: bool) : bool = @AS("bool_and a b");

#prec 20;
infix ||(a: bool, b: bool) : bool = @AS("bool_or a b");

#prec 20;
infix %(a: u64, b: u64) : u64 = @AS("int_signed_mod a b");


#prec 10;
macro infix =(a: _, b: _) = @AS("store_in a b");

#prec 10;
macro infix [=](a: _, b: _) = @AS("raw_store_in a b");

prefix !(a: bool) : bool = @AS("bool_not a");

#prec 75;
infix +(a: u64, b: u64) : u64 = @AS("int_add a b");

#prec 75;
infix -(a: u64, b: u64) : u64 = @AS("int_sub a b");

#prec 100;
infix *(a: u64, b: u64) : u64 = @AS("int_mul a b");

macro suffix ++(a: _) : _ = {
    a = a + 1;
    a
};

macro suffix --(a: _) : _ = {
    a = a - 1;
    a
};

#prec 10;
macro infix +=(a: _, b: _) : _ = {
    a = a + b;
    a
};

/* prec 10; */
/* macro infix -=(a: _, b: _) : _ = { */
/*     a = a - b; */
/*     a */
/* }; */
/**/
/* prec 10; */
/* macro infix *=(a: _, b: _) : _ = { */
/*     a = a * b; */
/*     a */
/* }; */

// TODO: fix this ugly mess
#prec 120;
infix ^(a: u64, b: u64) : u64 = {
  if b == 0 { 1 }
  else {
    total: u64 = a;
    while (b - 1) > 0 {
      total = total * a;
      b = b - 1;
    };
    total
  }
};

func assert(val: bool, message: &u8) = if !val {
        printf("Assertion failed: ");
        printf(message);
        printf("\n");
        exit(1)
    };

func assertVerbose(val: bool, message: &u8) = if val {
        printf("Assertion succeeded: ");
        printf(message);
        printf("\n");
    } else {
        printf("Assertion failed: ");
        printf(message);
        printf("\n");
        exit(1);
    };

overloadable func panic(message: &u8) = {
    printf("Panic!\n");
    printf(message);
    exit(1);
};

overloadable func panic() = {
    printf("Panic!\n");
    exit(1);
};

func debugPrint(message: &u8) = {
    printf(message);    
};


<T> func flatCopy(val: T) : &T = {
    data: &T = malloc(@sizeof(T)) as &T;
    memcpy(data as &u8, (&val) as &u8, @sizeof(T));

    data
};

// }}}

func printint(i: u64);

// STRING {{{

brackets [ ](str: &u8, index: u64) : &u8 = @AS("single_gep str index");

#prec 15;
infix ==(a: &u8, b: &u8) : bool = strcmp(a, b) == 0;

#prec 15;
infix !=(a: &u8, b: &u8) : bool = strcmp(a, b) != 0;

prefix copy(str: &u8) : &u8 = {
    dupl: &u8;
    dupl = malloc(str.strlen() + 1);
    strcpy(dupl, str);

    // bad debug tiem
    /* printf("Copied `"); */
    /* printf(dupl); */
    /* printf("` to `"); */
    /* print_addr(dupl); */
    /* printf("`\n"); */
    dupl
};

/* func length(str: &u8) : u64 = strlen(str); */

func contains(str: &u8, char: u8) : bool = {
    // TODO: revert to old logic after signage is fixed
    length: u64 = str.strlen();
    index: u64 = 0;
    while index != length {
        if *(str[index]) == char {
            return true 
        };
        index++;
    };
    false
};

func isNumeric(char: u8) : bool = (char >= '0') && (char <= '9');

func isAlpha(char: u8) : bool = ((char >= 'A') && (char <= 'Z') || (char >= 'a') && (char <= 'z'));

func isAlphanumeric(char: u8) : bool = char.isNumeric() || char.isAlpha();

func isWhitespace(char: u8) : bool = " \t\n".contains(char);

func printRepeatedChar(char: u8, repeat: u64) = {
    while repeat != 0 {
        putchar(' ');
        repeat--;
    };
};

func printIndentation(indentation: u64) = {
    putchar('\n');
    printRepeatedChar(' ', indentation);
};

// }}}

// LEXER {{{

// type str = &u8;

type Lexer = {
    input: &u8,
    index: u64,
    input_len: u64,
};

// input is not copied
func lexer#new(input: &u8) : Lexer = {
    lexer: Lexer;
    (&lexer).index = 0;
    (&lexer).input = input;
    (&lexer).input_len = (&lexer).input.strlen();
    lexer
};

func peek(lexer: &Lexer) : Lexer = {
    dupl: Lexer;
    &dupl.input = lexer.input;
    &dupl.index = lexer.index;
    (&dupl).input_len = lexer.input_len;
    dupl
};

func peekChar(lexer: &Lexer) : u8 = {
    if lexer.index >= lexer.input_len {
        return '\0';    
    };
    *((lexer.input)[lexer.index])
};

func takeChar(lexer: &Lexer) : u8 = {
    a: u8 = lexer.peekChar();
    lexer.index = lexer.index + 1;
    a
};

func isEof(lexer: &Lexer) : bool = lexer.index >= lexer.input_len;

type LexString = {
    parent: &Lexer,
    offset: u64,
    len: u64
};

#prec 75;
infix + (a: LexString, b: LexString) : LexString = {
    result: LexString;
    (&result).offset = (&a).offset;
    (&result).len = (&b).len + (&b).offset - (&a).offset;
    (&result).parent = (&a).parent;

    result
};

func lexstring#new(parent: &Lexer, start: u64, end: u64) : LexString = {
    lexstring: LexString;
    (&lexstring).parent = parent;
    (&lexstring).offset = start;
    (&lexstring).len = (end - start);

    lexstring
};

// BIG TODO: implment lambdas for more monadic operation

// must remember to free!
// also, might segfault
// TODO: bounds-check logic
func render(lexstring: &LexString) : &u8 = {
    str: &u8;
    str = malloc(lexstring.len + 1);
    strncpy(str, (lexstring.parent.input)[lexstring.offset], lexstring.len);
    str[lexstring.len] [=] '\0';
    str
};

func debugLexString(val: &LexString, indentation: u64) = {
    str: &u8 = val.render();
    printIndentation(indentation);
    printf(str);
    free str;
};

func takeNumber(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    first_dot: bool = true;
    // TODO: this specific logic feels stupid. surely there's a better way?
    while lexer.peekChar().isNumeric() || ((lexer.peekChar() == '.') && first_dot) {
        (&string.len)++;
        if lexer.takeChar() == '.' first_dot = false;
    };
    string
};

func isConventionalId(char: u8, first: bool) : bool = char.isAlpha() || (char.isNumeric() && !first) || (char == '_') || (char == '@');

func isSpecialId(char: u8) : bool = "+-><*/=%!&.[]|()".contains(char);

func takeIdentifier(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    first: bool = true;
    while lexer.peekChar().isConventionalId(first) {
        /* printf("LTAKE\n"); */
        (&string.len)++;
        if first { first = false; };
        lexer.takeChar();
    };

    if &string.len == 0 {
        while lexer.peekChar().isSpecialId() {
          /* printf("LTAKES\n"); */
            (&string.len)++;
            lexer.takeChar();
        };
    };

    string
};

func takeOnlyWhitespace(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    while lexer.peekChar().isWhitespace() {
        (&string.len)++;
        lexer.takeChar();
    };

    string
};

func takeComment(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;

    if lexer.peekChar() == '/' {
        peeked_: Lexer = lexer.peek();
        peeked: &Lexer = &peeked_;
        peeked.takeChar();
        c: u8 = peeked.peekChar();
        if c == '/' {
            lexer.takeChar();
            lexer.takeChar();

            (&string.len) += 2;

            while lexer.takeChar() != '\n' {
                (&string.len)++;
            };
        } else if c == '*' {
            lexer.takeChar();
            lexer.takeChar();

            (&string.len) += 2;

            while true {
                if lexer.takeChar() == '*' {
                    if lexer.peekChar() == '/' {
                            lexer.takeChar();
                            (&string.len) += 2;
                            break;
                    };
                };
                (&string.len)++;
            };
        };
    };

    string
};

func takeWhitespace(lexer: &Lexer) : LexString = {
    string: LexString = lexer.takeOnlyWhitespace();
    while lexer.peekChar() == '/' {
        string += lexer.takeComment();
        string += lexer.takeOnlyWhitespace();
    };

    string
};

overloadable func require(lexer: &Lexer, char: u8) : LexString = {
    lexer.takeWhitespace();
    
    string: LexString;
    (&string).offset = lexer.index;
    (&string).parent = lexer;
    (&string.len) = 1;

    c: u8 = lexer.takeChar();

    if c != char {
        printf("Expected `");
        putchar(char);
        printf("` but got `");
        putchar(c);
        printf("`\n");
        panic("invalid character");
    };
    string
};

overloadable func require(lexer: &Lexer, str: &u8) : LexString = {
    lexer.takeWhitespace();
    
    string: LexString = lexer.takeIdentifier();

    if (&string).render() != str {
        printf("Expected str `");
        printf(str);
        printf("` but got `");
        printf((&string).render());
        printf("`\n");
        panic("invalid character");
    };
    string
};

// }}}


// HASHMAP {{{
<K, V> type HMLinkedListElem = {
    hash: u64,
    val: &V,
    has_next_elem: bool,
    next_elem: &u8,// <T>HMLinkedListElem, // or 0 if no next elem, forgive me for using nullptrs
};

<K, V> prefix drop(elem: & <K, V>HMLinkedListElem) = {
    free(elem.val);
    if (elem.next_elem) as u64 != 0 {
        drop(elem.next_elem);
    };
    free(elem as &u8);
};

/* <T> type HMBucket = { */
/*     hash_offset: u8, */
/*     does_contain_sub_buckets: bool, */
/*     // array of length uhh 16 */
/*     sub_buckets: &&HMBucket, */
/*     // else, a linked list of values of max length uhh 8? */
/*     sub_values: <T> HMLinkedListElem, */
/*     sub_values_len: u8, */
/*     is_using_linked_list: bool, */
/* }; */

/* <T> func hmbucket#new(hash_offset: u8): <T> HMBucket = { */
/*     bucket: <T> HMBucket; */
/*     bucket.hash_offset = hash_offset; */
/*     bucket.sub_values_len = 0; */
/*     // TODO */
/*     bucket */
/* }; */

<K, V> overloadable func hmlist_contains_internal(self: & <K, V> HMLinkedListElem, hash: u64) : bool = {
  current: &<K, V>HMLinkedListElem = self;
  while true {
    /* printf("checking\n"); */
    if (current.hash) == hash { return true }
    else if !(current.has_next_elem) { return false }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem)}
  };
  false
};
<K, V> overloadable func hmlist_contains(self: & <K, V> HMLinkedListElem, key: K) : bool = self.hmlist_contains_internal<K, V>(hash(key));

<K, V> overloadable func hmlist_get(self: & <K, V> HMLinkedListElem, key: K) : &V = {
  hash: u64 = hash(key);
  current: & <K, V>HMLinkedListElem = self;
  while true {
    /* printf("get checking\n"); */
    if (current.hash) == hash { return (current.val) }
    else if ! (current.has_next_elem) { panic("Getting an element that doesn't exist") }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem) }
  };
  self.val
};

<K, V> overloadable func hmlist_get_elem_internal(self: & <K, V> HMLinkedListElem, hash: u64) : & <K, V> HMLinkedListElem = {
  current: &<K, V>HMLinkedListElem = self;
  while true {
    /* printf("getelem checking\n"); */
    if (current.hash) == hash { return current }
    else if !(current.has_next_elem) { panic("Getting an element that doesn't exist") }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem) }
  };
  self
};

<K, V> overloadable func hmlist_add(self: & <K, V> HMLinkedListElem, key: K, value: V) = {
  hash: u64 = hash(key);
  if self.hmlist_contains_internal<K, V>(hash) {
    elem: & <K, V>HMLinkedListElem = self.hmlist_get_elem_internal<K, V>(hash);
    elem.val = (malloc(@sizeof(V)) as &V);
    memcpy((elem.val) as &u8, (&value) as &u8, @sizeof(V));
  } else {
    elem: <K, V>HMLinkedListElem;
    (&elem).hash = hash;
    (&elem).val = (malloc(@sizeof(V)) as &V);
    memcpy((&(elem).val) as &u8, (&value) as &u8, @sizeof(V));
    &(elem).has_next_elem = (self.has_next_elem);
    &(elem).next_elem = (self.next_elem);
    elem2: & <K, V>HMLinkedListElem = malloc(@sizeof(elem)) as & <K, V>HMLinkedListElem;
    memcpy(elem2 as &u8, (&elem) as &u8, @sizeof(elem));
    (self.next_elem) = elem2 as &u8;
    (self.has_next_elem) = true;
  }
};

<K, V> func hmlist#new(key: K, value: V): <K, V> HMLinkedListElem = {
  elem: <K, V>HMLinkedListElem;
  &(elem).hash = hash(key);
  &(elem).val = (malloc(@sizeof(V)) as &V);
  memcpy((&(elem).val) as &u8, (&value) as &u8, @sizeof(V));
  &(elem).has_next_elem = false;
  elem
};


<K, V> overloadable func add(self: & <K, V>HMBucket, value: V, hash: u64) = {
  if self.is_using_linked_list {
    hnelem: bool = true;
    elem: <K, V> HMLinkedListElem = *(self.sub_values);
    while hnelem {
      if *(elem.hash) == hash {
        elem.val = value;
      };
      hnelem = *(elem.has_next_elem);
      elem = *(elem.next_elem);
    };
  };
};

<T> type HashMap = {
    buckets: &&HMBucket,
};

<T> prefix drop(elem: & <T> HMBucket) = {
    if elem.does_contain_sub_buckets {
        i: u8 = 0_8;
        while i != 16 {
            /* drop<T> elem.sub_buckets[i]; */
        };
    } else {
        /* drop<T> elem.sub_values; */
    };
    free(elem as &u8);
};
// }}}

// HASHINGS {{{
overloadable func hash(h: u64): u64 = h;
overloadable func hash(h: &u8): u64 = {
  i: u64 = 0;
  total: u64 = 0;
  while ((*h[i])) != 0_8 {
    q: u8 = *h[i];
    /* putchar(q); */
    /* putchar(':'); */
    /* printint(2^2); */
    p: u64 = @AS("int_z_extend q 64");
    total += (53^i) * p;
    i += 1;
  };
  total = (total % 1000000009);
  /* printf("Hash of "); */
  /* printf(h); */
  /* printint(total); */
  total
};
// }}}

// LIST {{{

<T> type VariableArray = {
    len: u64,
    set_size: u64,
    data: &T
};

/* <T> func shallow_copy(va: <T> VariableArray) : & <T> VariableArray = { */
/*     new: & <T> VariableArray = malloc(@sizeof(<T> VariableArray)); */
/*     memcpy(new as &u8, (&va) as &u8, @sizeof(<T> VariableArray)); */

/*     new */
/* }; */

<T> func variablearray#new() : <T> VariableArray = {
    va: <T> VariableArray;
    
    (&va).data = malloc(@sizeof(T) * 64) as &T;
    (&va).len = 0;
    (&va).set_size = @sizeof(T) * 64;

    va
};

<T> func get(va: & <T> VariableArray, index: u64) : &T = {
    data: &T = va.data;
    @AS("single_gep data index") as &T
};

// brackets [ ] (va: &<T> VariableArray, i: u64) : &T = va.get<T

<T> func set(va: & <T> VariableArray, index: u64, val: T) = {
    memcpy(((va.get<T>(index)) as &u8), (&val) as &u8, @sizeof(T));
};

<T> func append(va: & <T> VariableArray, val: T) = {
    va.len += 1;
    if (va.len * @sizeof(T)) > va.set_size {
        va.set_size += (@sizeof(T) * 64);
        va.data = (realloc((va.data) as &u8, va.set_size) as &T);
    };
    /* (*(va.get<T>(va.len - 1))) = val; */
    va.set<T>(va.len - 1, val);
};

<T> prefix drop(va: <T> VariableArray) = {

    free((&va).data);
};

<T> func va_contains(va: & <T> VariableArray, val: T) : bool = {
    i: u64 = 0;
    while i < va.len {
        if *(va.get<T>(i)) == val {
            return true;
        };
        i++;
    };
    false
};


<T> func va_indexof(va: & <T> VariableArray, val: T) : u64 = {
    i: u64 = 0;
    while i < va.len {
        if *(va.get<T>(i)) == val {
            return i;
        };
        i++;
    };

    0
};

// }}}

// BIG TODO: BOXES

// PARSER {{{

type Parser = {
    lexer: &Lexer,
    // first then last then another set etc
    brackets: <u8> VariableArray,
    prefixes: <&u8> VariableArray,
    suffixes: <&u8> VariableArray,
    binaries: <&u8, u64> HMLinkedListElem,
};


// Type parsing {{{
enum TypeType = {
    Reference,
    Named,
    Struct,
    Func,
    Template,
};

type TypeExpr = {
    source: LexString,
    variant: TypeType,
    value: &u8,
};

type NamedTypeExpr = {
    name: LexString,
};

type TemplateTypeExpr = {
    types: <TypeExpr> VariableArray,
    value: TypeExpr,
};

// TODO: Default values
type StructVarDef = {
    name: LexString,
    type: TypeExpr,
};

type StructTypeExpr = {
    types: <StructVarDef> VariableArray,
};

func parseType(parser: &Parser) : TypeExpr;

func debugTypeExpr(ty: &TypeExpr, indentation: u64);

func debugStructVarDef(s: &StructVarDef, indentation: u64) = {
    printIndentation(indentation);
    debugLexString(&(s.name), indentation + 2);
    printIndentation(indentation);
    printf(":");
    debugTypeExpr(&(s.type), indentation + 2);
};
func debugStructTypeExpr(s: &StructTypeExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("STRUCT TYPE DEF:");
    i: u64 = 0;
    while i < (&(s.types)).len {
        debugStructVarDef((&(s.types)).get<StructVarDef>(i), indentation + 2);
        i++;
    };
};

func parseStructTypeExpr(parser: &Parser) : TypeExpr = {
    parser.lexer.takeWhitespace();
    start: u64 = parser.lexer.index;
    parser.lexer.require('{');
    parser.lexer.takeWhitespace();
    s_vardefs: <StructVarDef> VariableArray = variablearray#new<StructVarDef>();
    while !(parser.lexer.isEof()) && parser.lexer.peekChar() != '}' {
        name: LexString = parser.lexer.takeIdentifier();
        if (&name).len == 0 { panic("Expected a name for a struct vardef"); };
        parser.lexer.takeWhitespace();
        parser.lexer.require(':');
        parser.lexer.takeWhitespace();
        type: TypeExpr = parser.parseType();
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != '}' {
            parser.lexer.require(',');
        };
        parser.lexer.takeWhitespace();
        s: StructVarDef;
        (&s).name = name;
        (&s).type = type;
        (&s_vardefs).append<StructVarDef>(s);
    };
    parser.lexer.require('}');
    end: u64 = parser.lexer.index;
    s: StructTypeExpr;
    (&s).types = s_vardefs;
    
    t: TypeExpr;
    (&t).variant = TypeType#Struct;
    (&t).source = lexstring#new(parser.lexer, start, end);
    (&t).value = (s.flatCopy<StructTypeExpr>()) as &u8;

    t
};

func debugTemplateTypeExpr(ty: &TemplateTypeExpr, indentation: u64);

func debugTypeExprInternal(ty: &TypeExpr, indentation: u64) = {
  /* printIndentation(indentation); */
    if ty.variant == TypeType#Reference {
        printf("& ");
        debugTypeExprInternal((ty.value) as &TypeExpr, indentation);
    } else if ty.variant == TypeType#Named {
        nte: &NamedTypeExpr = (ty.value) as &NamedTypeExpr;
        rendered: &u8 = (&(nte.name)).render();
        printf(rendered);
        free rendered;
    } else if ty.variant == TypeType#Template {
        debugTemplateTypeExpr((ty.value) as &TemplateTypeExpr, indentation);
    } else if ty.variant == TypeType#Struct {
        debugStructTypeExpr((ty.value) as &StructTypeExpr, indentation);
    } else {
        printf("Dunno how to debug this type type")
    }
};

func debugTypeExpr(ty: &TypeExpr, indentation: u64) = {
    printIndentation(indentation);
    debugTypeExprInternal(ty, indentation);
};

func debugTemplateTypeExpr(ty: &TemplateTypeExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TEMPLATE:");
    i: u64 = 0;
    while i < (&(ty.types)).len {
        debugTypeExpr((&(ty.types)).get<TypeExpr>(i), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("UNDERLYING:");
    debugTypeExpr(&(ty.value), indentation + 2);
};

prefix copy(ty: TypeExpr) : &TypeExpr = ty.flatCopy<TypeExpr>();
prefix copy(ty: NamedTypeExpr) : &NamedTypeExpr = ty.flatCopy<NamedTypeExpr>();
prefix copy(ty: TemplateTypeExpr) : &TemplateTypeExpr = ty.flatCopy<TemplateTypeExpr>();


func parseTemplateList(parser: &Parser) : <TypeExpr> VariableArray = {
    parser.lexer.require('<');
    types: <TypeExpr> VariableArray = variablearray#new<TypeExpr>();
    parser.lexer.takeWhitespace();
    while (parser.lexer.peekChar() != '>') && !(parser.lexer.isEof()) {
      (&types).append<TypeExpr>(parser.parseType());
      parser.lexer.takeWhitespace();
      if parser.lexer.peekChar() != '>' {
        parser.lexer.require(',');
        parser.lexer.takeWhitespace();
      };
    };
    parser.lexer.require('>');
    parser.lexer.takeWhitespace();
    types
};

func parseType(parser: &Parser) : TypeExpr = {
  parser.lexer.takeWhitespace();
  c: u8 = parser.lexer.peekChar();
  if c == '&' {
    // ah its a uhh
    // pointer!
    parser.lexer.takeChar();
    parser.lexer.takeWhitespace();
    ty_: TypeExpr = parser.parseType();
    ty: &TypeExpr = copy ty_;
    res: TypeExpr;
    (&res).variant = TypeType#Reference;
    (&res).value = (ty as &u8);
    res
  } else if c == '<' {
    t: TemplateTypeExpr;
    (&t).types = parser.parseTemplateList();
    (&t).value = parser.parseType();
    ty: TypeExpr;
    (&ty).variant = TypeType#Template;
    (&ty).value = (copy t) as &u8;
    ty
  } else if c == '{' {
    t: TypeExpr = parser.parseStructTypeExpr();
    t
  } else {
    // TODO: structs, funcs
    name: LexString = parser.lexer.takeIdentifier();
    ty_: NamedTypeExpr;
    (&ty_).name = name;
    ty: &NamedTypeExpr = copy ty_;
    res: TypeExpr;
    (&res).variant = TypeType#Named;
    (&res).value = (ty as &u8);
    res
  }
};

// TODO: all the rest of the types; lambdas; templates

/* type StructTypeExpr { */
    /*  */
/* }; */
//  }}}

enum ExprType = {
    Number,
    Identifier,
    Block,
    String,
    If,
    While,
    Vardef,
    Return,
    Cast,
    CDef,
    PostfixBrackets,
    PrefixCall,
    SuffixCall,
    TemplatedExpr,
    Binary
};

type Expr = {
    value: &u8, // something something data pointer
    variant: ExprType
};

type NumberExpr = {
    source: LexString,
    parsed: u64,
};

type IdentifierExpr = {
    source: LexString,
    // TODO: namespaces
};
type VardefExpr = {
    source: LexString,
    ty: TypeExpr,
    var: IdentifierExpr,
};

func intoVardefExpr(e: &Expr) : &VardefExpr = {
    if e.variant != ExprType#Vardef {panic("Into-ed vardef, did not get it")};
    (e.value) as &VardefExpr
};

type BlockExpr = {
    source: LexString,
    exprs: <Expr> VariableArray,
    use_last_val: bool,
};

type StringExpr = {
    source: LexString,
    value: &u8,
};

type IfExpr = {
    source: LexString,
    cond: Expr,
    then: Expr,
    has_else: bool,
    else: Expr,
};

type WhileExpr = {
    source: LexString,
    cond: Expr,
    then: Expr,
};

type ReturnExpr = {
    source: LexString,
    has_val: bool,
    val: Expr,
};

type CastExpr = {
    source: LexString,
    val: Expr,
    ty: TypeExpr,
};

// TODO: make work with longer than 1-char brackets
type PostfixBracketsExpr = {
    source: LexString,
    val: Expr,
    brack_first: u8,
    brack_last: u8,
    args: <Expr> VariableArray,
};

type PrefixCallExpr = {
    source: LexString,
    val: Expr,
    prefix: IdentifierExpr,
};

type SuffixCallExpr = {
    source: LexString,
    val: Expr,
    suffix: IdentifierExpr,
};

type TemplatedExpr = {
    types: <TypeExpr> VariableArray,
    val: Expr,
};

type BinaryExpr = {
    lhs: Expr,
    rhs: Expr,
    op: IdentifierExpr,
};

// type CDefExpr


// lexer is moved
func parser#new(lexer: &Lexer) : Parser = {
    parser: Parser;
    (&parser).lexer = lexer;
    (&parser).brackets = variablearray#new<u8>();
    (&parser).prefixes = variablearray#new<&u8>();
    (&parser).suffixes = variablearray#new<&u8>();
    (&((&parser).brackets)).append<u8>('(');
    (&((&parser).brackets)).append<u8>(')');
    (&parser).binaries = hmlist#new<&u8, u64>("+", 50);
    (&((&parser).binaries)).hmlist_add<&u8, u64>("*", 100);
    // TODO: THIS IS TESTING PLZ REMOVE
    // (&((&parser).prefixes)).append<&u8>("free");
    // (&((&parser).suffixes)).append<&u8>("_s");

    parser
};

overloadable func debugExprType(val: &ExprType, indentation: u64) = {
    printIndentation(indentation);
    if *val == ExprType#Number {
        printf("ExprType#Number");
    } else if *val == ExprType#Identifier {
        printf("ExprType#Identifier");
    } else if *val == ExprType#Block {
        printf("ExprType#Block");
    } else if *val == ExprType#String {
        printf("ExprType#String");
    } else if *val == ExprType#If {
        printf("ExprType#If");
    } else if *val == ExprType#While {
        printf("ExprType#While");
    } else if *val == ExprType#Vardef {
        printf("ExprType#Vardef");
    } else if *val == ExprType#Return {
        printf("ExprType#Return");
    } else if *val == ExprType#Cast {
        printf("ExprType#Cast");
    } else if *val == ExprType#PostfixBrackets {
        printf("ExprType#PostfixBrackets");
    } else if *val == ExprType#PrefixCall {
        printf("ExprType#PrefixCall");
    } else if *val == ExprType#SuffixCall {
        printf("ExprType#SuffixCall");
    } else if *val == ExprType#TemplatedExpr {
        printf("ExprType#TemplatedExpr");
    } else if *val == ExprType#Binary {
        printf("ExprType#Binary");
    } else {
        printf("Debug expr type for this one not implmented yet");
    }
};


// forward-def
func parsePrimaryExpr(parser: &Parser) : Expr;
// GOT HERE, need to forward-def overloadbles
func debugBlockExpr(val: &BlockExpr, indentation: u64);
func debugIdentifierExpr(val: &IdentifierExpr, indentation: u64);
func debugVardefExpr(val: &VardefExpr, indentation: u64);
func debugNumberExpr(val: &NumberExpr, indentation: u64);
func debugStringExpr(val: &StringExpr, indentation: u64);
func debugIfExpr(val: &IfExpr, indentation: u64);
func debugWhileExpr(val: &WhileExpr, indentation: u64);
func debugReturnExpr(val: &ReturnExpr, indentation: u64);
func debugCastExpr(val: &CastExpr, indentation: u64);
func debugPostfixBracketsExpr(val: &PostfixBracketsExpr, indentation: u64);
func debugPrefixCallExpr(val: &PrefixCallExpr, indentation: u64);
func debugSuffixCallExpr(val: &SuffixCallExpr, indentation: u64);
func debugTemplatedExpr(t: &TemplatedExpr, indentation: u64);
func debugBinaryExpr(b: &BinaryExpr, indentation: u64);

overloadable func debugExpr(val: &Expr, indentation: u64) = {
    debugExprType(&(val.variant), indentation);
    if val.variant == ExprType#Block {
        debugBlockExpr((val.value) as &BlockExpr, indentation);
    } else if val.variant == ExprType#Identifier {
        debugIdentifierExpr((val.value) as &IdentifierExpr, indentation);
    } else if val.variant == ExprType#Number {
        debugNumberExpr((val.value) as &NumberExpr, indentation);
    } else if val.variant == ExprType#String {
        debugStringExpr((val.value) as &StringExpr, indentation);
    } else if val.variant == ExprType#If {
        debugIfExpr((val.value) as &IfExpr, indentation);
    } else if val.variant == ExprType#While {
        debugWhileExpr((val.value) as &WhileExpr, indentation);
    } else if val.variant == ExprType#Vardef {
        debugVardefExpr((val.value) as &VardefExpr, indentation);
    } else if val.variant == ExprType#Return {
        debugReturnExpr((val.value) as &ReturnExpr, indentation);
    } else if val.variant == ExprType#Cast {
        debugCastExpr((val.value) as &CastExpr, indentation);
    } else if val.variant == ExprType#PostfixBrackets {
        debugPostfixBracketsExpr((val.value) as &PostfixBracketsExpr, indentation);
    } else if val.variant == ExprType#PrefixCall {
        debugPrefixCallExpr((val.value) as &PrefixCallExpr, indentation);
    } else if val.variant == ExprType#SuffixCall {
        debugSuffixCallExpr((val.value) as &SuffixCallExpr, indentation);
    } else if val.variant == ExprType#TemplatedExpr {
        debugTemplatedExpr((val.value) as &TemplatedExpr, indentation);
    } else if val.variant == ExprType#Binary {
        debugBinaryExpr((val.value) as &BinaryExpr, indentation);
    } else {
        printf("Dunno how to debug this type");
    }
};

prefix drop(expr: Expr) = {
    free (&expr.value);
};

func parseExpr(parser: &Parser) : Expr;

func debugNumberExpr(val: &NumberExpr, indentation: u64) = {
    debugLexString(&(val.source), indentation);
};

func parseNumberExpr(parser: &Parser) : NumberExpr = {
    debugPrint("Parsing number\n");
    number: LexString = parser.lexer.takeNumber();
    if &number.len == 0 {
        panic("Expected number");
    };
    expr: NumberExpr;
    &expr.source = number;

    // TODO: atoi

    expr
};

prefix copy(val: NumberExpr) : &NumberExpr = {
    data: &NumberExpr = malloc(@sizeof(NumberExpr)) as &NumberExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(NumberExpr));

    data
};

overloadable func asExpr(number: NumberExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Number;

    // TODO: make it more silvery
    &expr.value = (copy number) as &u8;

    expr
};


func debugIdentifierExpr(val: &IdentifierExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("`");
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    printf("`");
    // debugLexString(&(val.source), indentation);
};

func parseIdentifierExpr(parser: &Parser) : IdentifierExpr = {
    debugPrint("Parsing identifier expr\n");
    id: LexString = parser.lexer.takeIdentifier();
    if &id.len == 0 {
        panic("Expected valid identifier");
    };
    expr: IdentifierExpr;
    &expr.source = id;

    expr
};

prefix copy(val: IdentifierExpr) : &IdentifierExpr = {
    data: &IdentifierExpr = malloc(@sizeof(IdentifierExpr)) as &IdentifierExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(IdentifierExpr));

    data
};

overloadable func asExpr(id: IdentifierExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Identifier;

    &expr.value = (copy id) as &u8;

    expr
};

prefix copy (val: VardefExpr) : &VardefExpr = val.flatCopy<VardefExpr>();

func debugVardefExpr(val: &VardefExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("VARDEF `");
    id: &u8 = (&((&(val.var)).source)).render();
    printf(id);
    free id;
    printf("` DEFINED WITH TYPE");
    debugTypeExpr(&(val.ty), indentation + 2);
};

overloadable func asExpr(v: VardefExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Vardef;
    &expr.value = (copy v) as &u8;

    expr
};

func maybeVardefExpr(parser: &Parser, id: IdentifierExpr) : Expr = {
  parser.lexer.takeWhitespace();
  if parser.lexer.peekChar() == ':' {
    parser.lexer.takeChar();
    parser.lexer.takeWhitespace();
    ty_: TypeExpr = parser.parseType();
    ty: &TypeExpr = copy ty_;
    v_: VardefExpr;
    v: &VardefExpr = &v_;
    v.source = (&id.source) + ty.source;
    v.var = id;
    v.ty = ty_;
    v_.asExpr()
  } else { id.asExpr() }
};

func debugBlockExpr(val: &BlockExpr, indentation: u64) = {
    printIndentation(indentation);
    exprs: <Expr> VariableArray;
    exprs = val.exprs;

    printf("BLOCK: {");
    i: u64 = 0;
    while i < (&exprs).len {
        debugExpr(((&(val.exprs)).get<Expr>(i)), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("} using last value: ");
    printf(
        if val.use_last_val {
          "true"
        } else { "false" }
    );
};

func parseBlockExpr(parser: &Parser) : BlockExpr = {
    // debugPrint("Parsing block expr\n");
    parser.lexer.takeWhitespace();

    start: u64 = parser.lexer.index;
    
    parser.lexer.require('{');
    expr: BlockExpr;
    exprs: <Expr> VariableArray = variablearray#new<Expr>();

    last_semicolon: bool = true;

    while !(parser.lexer.isEof()) && (parser.lexer.peekChar() != '}') {
        internal_expr: Expr = parser.parseExpr();
        printf("parsing ex\n");
        debugExprType(&((&internal_expr).variant), 0);
        (&exprs).append<Expr>(internal_expr);
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() == '}' {
            debugPrint("Broke loop\n");
            debugPrint("got: ");
            last_semicolon = false;
            break;
        };
        // Don't require semicolons after blocks
        if &internal_expr.variant != ExprType#Block {
          parser.lexer.require(';')
        } else {
            if parser.lexer.peekChar() == ';' {
                parser.lexer.require(';');
            };
        };
        parser.lexer.takeWhitespace();
    };

    parser.lexer.require('}');
//    printf("len: ");
//    printint((&exprs).len);

    end: u64 = parser.lexer.index;

    (&expr).exprs = exprs;
    (&expr).source = lexstring#new(parser.lexer, start, end);
    (&expr).use_last_val = !last_semicolon;

    expr
};

prefix copy(val: BlockExpr) : &BlockExpr = {
    data: &BlockExpr = malloc(@sizeof(BlockExpr)) as &BlockExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(BlockExpr));

    data
};

overloadable func asExpr(id: BlockExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#Block;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugStringExpr(val: &StringExpr, indentation: u64) = {
    printIndentation(indentation);    
  /* printf("`"); */
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseStringExpr(parser: &Parser) : StringExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('"');

    str: <u8> VariableArray = variablearray#new<u8>();
    escaped: bool = false;
    while true {
        next_char: u8 = parser.lexer.takeChar();
        if escaped {
            (&str).append<u8>(next_char);
        } else {
            if next_char == '\\' {
                escaped = true;
            } else if next_char == '"' {
                break;
            } else {
                (&str).append<u8>(next_char);
            }
        }
    };

    end: u64 = parser.lexer.index;
    s: StringExpr;
    (&s).source = lexstring#new(parser.lexer, start, end);
    (&s).value = (&str).data;

    s
};

prefix copy(val: StringExpr) : &StringExpr = {
    data: &StringExpr = malloc(@sizeof(StringExpr)) as &StringExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(StringExpr));

    data
};

overloadable func asExpr(id: StringExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#String;

    (&expr).value = (copy id) as &u8;

    expr
};


func debugIfExpr(val: &IfExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("IF: ");
    debugExpr(&(val.cond), indentation + 2);
    printIndentation(indentation);
    printf("THEN: ");
    debugExpr(&(val.then), indentation + 2);
    if (val.has_else) {
      printIndentation(indentation);
      printf("ELSE: ");
      debugExpr(&(val.else), indentation + 2);
    };
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseIfExpr(parser: &Parser) : IfExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("if");
    
    cond: Expr = parseExpr(parser);
    then: Expr = parseExpr(parser);
    parser.lexer.takeWhitespace();

    else: Expr;
    peek_: Lexer = parser.lexer.peek();
    peeked: &Lexer = &peek_;
    n_id: LexString = peeked.takeIdentifier();
    next: &u8 = (&n_id).render();
    has_else: bool = if next == "else" {
        parser.lexer.takeIdentifier();
        else = parser.parseExpr();
        true
    } else false;

    free next;

    end: u64 = parser.lexer.index;
    i: IfExpr;
    (&i).source = lexstring#new(parser.lexer, start, end);
    (&i).cond = cond;
    (&i).then = then;
    (&i).else = else;
    (&i).has_else = has_else;

    i
};

prefix copy(val: IfExpr) : &IfExpr = flatCopy<IfExpr>(val);

overloadable func asExpr(id: IfExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#If;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugWhileExpr(val: &WhileExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("WHILE: ");
    debugExpr(&(val.cond), indentation + 2);
    printIndentation(indentation);
    printf("DO: ");
    debugExpr(&(val.then), indentation + 2);
};

func parseWhileExpr(parser: &Parser) : WhileExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("while");
    
    cond: Expr = parseExpr(parser);
    then: Expr = parseExpr(parser);

    end: u64 = parser.lexer.index;
    w: WhileExpr;
    (&w).source = lexstring#new(parser.lexer, start, end);
    (&w).cond = cond;
    (&w).then = then;
    w
};

prefix copy(val: WhileExpr) : &WhileExpr = flatCopy<WhileExpr>(val);

overloadable func asExpr(id: WhileExpr) : Expr = {
  expr: Expr;
  (&expr).variant = ExprType#While;
  (&expr).value = (copy id) as &u8;

  expr
};

func debugReturnExpr(val: &ReturnExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("RETURN ");
    if val.has_val {
        printf("VAL");
        debugExpr(&(val.val), indentation + 2);
    } else {
        printf("NONE");
    };
};

func parseReturnExpr(parser: &Parser) : ReturnExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("return");

    parser.lexer.takeWhitespace();
    c: u8 = parser.lexer.peekChar();
    has_val: bool = !((c == ';') || (c == '}'));

    val: Expr;

    if has_val {
        val = parser.parseExpr();
    };

    end: u64 = parser.lexer.index;

    r: ReturnExpr;
    (&r).has_val = has_val;
    (&r).val = val;
    (&r).source = lexstring#new(parser.lexer, start, end);
    r
};

prefix copy(val: ReturnExpr) : &ReturnExpr = flatCopy<ReturnExpr>(val);

overloadable func asExpr(id: ReturnExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#Return;
    (&expr).value = (copy id) as &u8;

    expr
};

prefix copy (val: CastExpr) : &CastExpr = val.flatCopy<CastExpr>();

func debugCastExpr(val: &CastExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("CAST");
    (&(val.val)).debugExpr(indentation + 2);
    printIndentation(indentation);
    printf("TO");
    debugTypeExpr(&(val.ty), indentation + 2);
};

overloadable func asExpr(v: CastExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Cast;
    &expr.value = (copy v) as &u8;

    expr
};

func maybeCastExpr(parser: &Parser, e: Expr) : Expr = {
  start: u64 = parser.lexer.index;
  parser.lexer.takeWhitespace();
  peeked: Lexer = parser.lexer.peek();
  next: &u8;
  ls: LexString = (&peeked).takeIdentifier();
  next = (&ls).render();
  ex: Expr = if next == "as" {
    parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    ty_: TypeExpr = parser.parseType();
    ty: &TypeExpr = copy ty_;
    v_: CastExpr;
    v: &CastExpr = &v_;
    v.source = lexstring#new(parser.lexer, start, parser.lexer.index);
    v.val = e;
    v.ty = ty_;
    v_.asExpr()
  } else { e };
  free next;
  ex
};

func debugPostfixBracketsExpr(val: &PostfixBracketsExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("POSTFIX BRACKETS:");
    printIndentation(indentation);
    putchar(val.brack_first);
    putchar(' ');
    putchar(val.brack_last);

    printIndentation(indentation);
    printf("UPON:");
    debugExpr(&(val.val), indentation + 2);
    printIndentation(indentation);
    printf("ARGS:");
    i: u64 = 0;
    while i < (&(val.args)).len {
        debugExpr((&(val.args)).get<Expr>(i), indentation + 2);
        i++;
    };
    
};

prefix copy(v: PostfixBracketsExpr) : &PostfixBracketsExpr = flatCopy<PostfixBracketsExpr>(v);

overloadable func asExpr(v: PostfixBracketsExpr) : Expr = {
    e: Expr;
    (&e).variant = ExprType#PostfixBrackets;
    (&e).value = (copy v) as &u8;

    e
};

func maybePostfixBracketsExpr(parser: &Parser, e: Expr) : Expr = {
    start: u64 = parser.lexer.index;
    /*
    parser.lexer.takeWhitespace();
    peeked: Lexer = parser.lexer.peek();
    ls: LexString = (&peeked).takeIdentifier();
    first: &u8 = (&ls).render();
    */
    first: u8 = parser.lexer.peekChar();
    if !((&(parser.brackets)).va_contains<u8>(first)) { return e; };
    idx: u64 = (&(parser.brackets)).va_indexof<u8>(first);
    if (idx % 2) != 0 {return e;};
    last: u8 = *((&(parser.brackets)).get<u8>(idx + 1));
    // skreeee
    // id_first: IdentifierExpr = parser.parseIdentifierExpr();
    parser.lexer.takeChar();
    parser.lexer.takeWhitespace();

    exprs: <Expr> VariableArray = variablearray#new<Expr>();


    while !(parser.lexer.isEof()) && !({
        parser.lexer.peekChar() == last
    }) {
        internal_expr: Expr = parser.parseExpr();
        (&exprs).append<Expr>(internal_expr);
        parser.lexer.takeWhitespace();
        if {
            parser.lexer.peekChar() == last
        } {
            break;
        };
        parser.lexer.require(',');

        parser.lexer.takeWhitespace();
    };

    parser.lexer.require(last);

    ex: PostfixBracketsExpr;
    (&ex).source = lexstring#new(parser.lexer, start, parser.lexer.index);
    (&ex).val = e;
    (&ex).brack_first = first;
    (&ex).brack_last = last;
    (&ex).args = exprs;


    ex.asExpr()
};

func debugPrefixCallExpr(p: &PrefixCallExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("PREFIX CALL:");
    debugIdentifierExpr(&(p.prefix), indentation + 2);
    printIndentation(indentation);
    printf("UPON");
    debugExpr(&(p.val), indentation + 2);
};

prefix copy(p: PrefixCallExpr) : &PrefixCallExpr = p.flatCopy<PrefixCallExpr>();

overloadable func asExpr(p: PrefixCallExpr) : Expr = {
    e: Expr;
    printf("prefix asexprd");
    (&e).variant = ExprType#PrefixCall;
    (&e).value = (copy p) as &u8;
    e
};

func maybePrefixCallExpr(parser: &Parser, i: IdentifierExpr) : Expr = {
    r: &u8 = (&((&i).source)).render();
    if (&(parser.prefixes)).va_contains<&u8>(r) {
      printf("PREFIXED");
      free r;
        p: PrefixCallExpr;
        (&p).prefix = i;
        (&p).val = parser.parsePrimaryExpr();
        end: u64 = parser.lexer.index;
        start: u64 = (&((&i).source)).offset;
        (&p).source = lexstring#new(parser.lexer, start, end);
        p.asExpr()
    } else {
      free r;
      i.asExpr()
    }
};

func debugSuffixCallExpr(p: &SuffixCallExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("SUFFIX CALL:");
    debugIdentifierExpr(&(p.suffix), indentation + 2);
    printIndentation(indentation);
    printf("UPON");
    debugExpr(&(p.val), indentation + 2);
};

// prefix copy(s: SuffixCallExpr) : &SuffixCallExpr = s.flatCopy<SuffixCallExpr>();
//prefix copy(s: SuffixCallExpr) : &SuffixCallExpr = flatCopy<SuffixCallExpr>(s);
// IDK why it no work as other one
prefix copy(s: SuffixCallExpr) : &SuffixCallExpr = {
  a: &SuffixCallExpr = flatCopy<SuffixCallExpr>(s);
  a
};
// prefix copy(s: )

// again IDK why
overloadable func sf_asExpr(p: SuffixCallExpr) : Expr = {
    e: Expr;
    printf("is var suffix");
    (&e).variant = ExprType#SuffixCall;
    (&e).value = (copy p) as &u8;
    e
};

func maybeSuffixCallExpr(parser: &Parser, e: Expr) : Expr = {
    parser.lexer.takeWhitespace();
    l: Lexer = parser.lexer.peek();
    ls: LexString = (&l).takeIdentifier();
    sf: &u8 = (&ls).render();
    if (&(parser.suffixes)).va_contains<&u8>(sf) {
        printf("suffixed");
        free sf;
        start: u64 = parser.lexer.index;
        s: SuffixCallExpr;
        (&s).suffix = parser.parseIdentifierExpr();
        (&s).val = e;
        end: u64 = parser.lexer.index;
        (&s).source = lexstring#new(parser.lexer, start, end);
        s.sf_asExpr()
    } else {
      free sf;
      e
    }
};

prefix copy(t: TemplatedExpr) : &TemplatedExpr = t.flatCopy<TemplatedExpr>();

overloadable func asExpr(t: TemplatedExpr) : Expr = {
    ex: Expr;
    (&ex).variant = ExprType#TemplatedExpr;
    (&ex).value = (copy t) as &u8;
    ex
};

func debugTemplatedExpr(t: &TemplatedExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TEMPLATED EXPR:");
    i: u64 = 0;
    while i < (&(t.types)).len {
        debugTypeExpr((&(t.types)).get<TypeExpr>(i), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("UNDERLYING:");
    debugExpr(&(t.val), indentation + 2);
};

func maybeTemplatedExpr(parser: &Parser, e: Expr) : Expr = {
    parser.lexer.takeWhitespace();
    if parser.lexer.peekChar() == '<' {
        types: <TypeExpr> VariableArray = parser.parseTemplateList();
        t: TemplatedExpr;
        (&t).types = types;
        (&t).val = e;
        t.asExpr()
    } else {e}
};

// DOES NOT HANDLE BINARY SHENANIGANS

func parsePrimaryExpr(parser: &Parser) : Expr = {
    parser.lexer.takeWhitespace();

    next_char: u8 = parser.lexer.peekChar();
    ex: Expr = if next_char.isNumeric() {
        parser.parseNumberExpr().asExpr()
    } else if next_char == '(' {
        parser.lexer.takeChar();
        e: Expr = parser.parseExpr();
        parser.lexer.takeWhitespace();
        parser.lexer.require(')');
        e
    } else if (next_char.isConventionalId(true) || next_char.isSpecialId()) {
        peeked_: Lexer = (parser.lexer.peek());
        peeked: &Lexer = &peeked_;
        nextTok: LexString = peeked.takeIdentifier();
        next: &u8 = (&nextTok).render();
        e: Expr = if next == "if" {parser.parseIfExpr().asExpr()}
        else if next == "while" {parser.parseWhileExpr().asExpr()}
        else if next == "return" {parser.parseReturnExpr().asExpr()}
        else {
          id: IdentifierExpr = parser.parseIdentifierExpr();
          v: Expr = parser.maybeVardefExpr(id);
          if (&v).variant == ExprType#Identifier {
            v = parser.maybePrefixCallExpr(id);
          };
          v
        };
        free next;
        e
    } else if next_char == '{' {
        ba: BlockExpr = parser.parseBlockExpr();
        e: Expr = ba.asExpr();
        e
    } else if next_char == '"' {
      parser.parseStringExpr().asExpr()
    } else {
        expr: Expr;
        printf("Cannot parse: `");
        putchar(next_char);
        printf("`\n");
        panic();

        expr
    };
    // TODO: fix this, maybe iterate until no changes?
    ex = parser.maybeTemplatedExpr(ex);
    ex = parser.maybePostfixBracketsExpr(ex);
    ex = parser.maybeSuffixCallExpr(ex);
    ex = parser.maybeCastExpr(ex);
    ex
};

prefix copy(b: BinaryExpr) : &BinaryExpr = b.flatCopy<BinaryExpr>();

func asExpr(b: BinaryExpr) : Expr = {
    ex: Expr;
    (&ex).variant = ExprType#Binary;
    (&ex).value = (copy b) as &u8;

    ex
};

func debugBinaryExpr(b: &BinaryExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("BINARY:");
    debugIdentifierExpr(&(b.op), indentation + 2);
    printIndentation(indentation);
    printf("LHS:");
    debugExpr(&(b.lhs), indentation + 2);
    printIndentation(indentation);
    printf("RHS:");
    debugExpr(&(b.rhs), indentation + 2);
};

func parseBinary(parser: &Parser, lhs_: Expr, current_prec: u64) : Expr = {
    lhs: Expr = lhs_;
    while true {
      parser.lexer.takeWhitespace();
      peekl: Lexer = parser.lexer.peek();
      id: LexString = (&peekl).takeIdentifier();
      peeked: &u8 = (&id).render();
      if !((&(parser.binaries)).hmlist_contains<&u8, u64>(peeked)) { free peeked; return lhs; };
      their_prec: u64 = *((&(parser.binaries)).hmlist_get<&u8, u64>(peeked));
      free peeked;
      if current_prec > their_prec { return lhs; };
      // okay take it
      op: IdentifierExpr = parser.parseIdentifierExpr();
      // and the rhs
      rhs: Expr = parser.parsePrimaryExpr();

      // identity theft
      our_prec: u64 = their_prec;

      parser.lexer.takeWhitespace();
      peekl = parser.lexer.peek();
      id = (&peekl).takeIdentifier();
      peeked = (&id).render();
    
      // TODO: negative numbers (!)
      their_prec = if !((&(parser.binaries)).hmlist_contains<&u8, u64>(peeked)) { 0 }
      else { *((&(parser.binaries)).hmlist_get<&u8, u64>(peeked)) };

      // if theirs is bigger than ours consider it first
      rhs = if their_prec > our_prec { parser.parseBinary(rhs, our_prec) }
      else { rhs };

      lhsnew: BinaryExpr;
      (&lhsnew).lhs = lhs;
      (&lhsnew).rhs = rhs;
      (&lhsnew).op = op;

      lhs = lhsnew.asExpr();
    };

    lhs
};

func parseExpr(parser: &Parser) : Expr = parser.parseBinary(parser.parsePrimaryExpr(), 0);

// }}}

// TL-PARSING {{{

enum TLExprType = {
    CDef,
    Function,
    Typedef,
    Enum,
};

type TLExpr = {
    variant: TLExprType,
    value: &u8
};

type EnumTLExpr = {
    source: LexString,
    names: <IdentifierExpr> VariableArray,
    name: LexString,
};

func debugEnumTLExpr(e: &EnumTLExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("ENUM:");
    debugLexString(&(e.name), indentation);
    i: u64 = 0;
    while i < (&(e.names)).len {
        debugIdentifierExpr((&(e.names)).get<IdentifierExpr>(i), indentation + 2);
        i++
    };
};

func parseEnumTLExpr(parser: &Parser) : EnumTLExpr = {
    parser.lexer.takeWhitespace();
    start: u64 = parser.lexer.index;
    l: LexString = (parser.lexer.takeIdentifier());
    kwd: &u8 = (&l).render();
    if kwd != "enum" {
        panic("Expected `enum`");
    };
    parser.lexer.takeWhitespace();
    name: LexString = parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    parser.lexer.require('=');
    parser.lexer.takeWhitespace();
    parser.lexer.require('{');
    parser.lexer.takeWhitespace();
    
    names: <IdentifierExpr> VariableArray = variablearray#new<IdentifierExpr>();

    while !(parser.lexer.isEof()) && parser.lexer.peekChar() != '}' {
          (&names).append<IdentifierExpr>(parser.parseIdentifierExpr());
          parser.lexer.takeWhitespace();
          if parser.lexer.peekChar() != '}' {
              parser.lexer.require(',');
              parser.lexer.takeWhitespace();
          };
    };

    end: u64 = parser.lexer.index;

    e: EnumTLExpr;
    (&e).source = lexstring#new(parser.lexer, start, end);
    (&e).names = names;
    (&e).name = name;

    e
};

//  }}}

// MAIN {{{

func main() : u64 = {
    code: &u8 = "enum pqrs = {a, q, p}";
    lexer: &Lexer = &lexer#new(code);
    parser: &Parser = &parser#new(lexer);
    e: EnumTLExpr = parser.parseEnumTLExpr();
    debugEnumTLExpr(&e, 0);
    // e: Expr = parser.parseExpr();
    // (&e).debugExpr(0);
    /* printf("main"); */
    /* data: &u8 = malloc(9223372036854775807 * @sizeof(u64)); */
    /* (*data[0]) = 7_8; */
    /* printf("begin\n"); */
    /* code: &u8 = "178.7492 aa 786 bcd"; */
    /* lexer: &Lexer = &lexer#new(code); */
    /**/
    /*  */
    /* string: &LexString = & &(lexer.takeWhitespace()); */
    /* printf(string.render()); */
    /**/
    /* putchar('\n'); */

    /* string: &LexString = & &(lexer.takeNumber()); */
    /* printf(string.render()); */
    /**/
    /* putchar('\n'); */
    /**/
    /* lexer.takeWhitespace(); */
    /**/
    /* string = & &(lexer.takeIdentifier()); */
    /* printf(string.render()); */
    /* putchar('\n'); */
    /**/
    /* parser: &Parser = &parser#new(lexer); */
    /**/
    /* parser.parseNumberExpr(); */
    /* parser.parseNumberExpr(); */

    /* va: <&u8> VariableArray; */
    /* va = variablearray#new<&u8>(); */

    /* (&va).append<&u8>("he"); */

    /* printf(*((&va).get<&u8>(0))); */

    /* va: <u64> VariableArray; */
    /* va = variablearray#new<u64>(); */

    /* (&va).append<u64>(7); */

    /* if *((&va).get<u64>(0)) == 7 { */
    /*     printf("yay\n"); */
    /* }; */
    /* if *((&va).get<u64>(0)) == 0 { */
    /*     printf("noo\n"); */
    /* }; */

    /* if (&va).len == 1 { */
    /*     printf("correct length\n"); */
    /* }; */
    /* va: <&u8> VariableArray; */
    /* va = variablearray#new<&u8>(); */
    /* (&va).append<&u8>("hello\n"); */
    /* s: &&u8 = (&va).get<&u8>(0); */
    /* printf(*s); */

    /* source: &u8 = "{\"babc\"}"; */

    /* lexer: &Lexer = &lexer#new(source); */
    /* parser: &Parser = &parser#new(lexer); */

    /* printf("hello"); */

    /* expr: Expr = parser.parseExpr(); */

    /* printf("here lol\n"); */

    /* printf("Input was:\n"); */
    /* printf(source); */

    /* printf("\nOutput was:\n"); */

    /* debugExpr(&expr, 0); */
    /* printf("here20"); */
    /* q: <&u8, &u8> HMLinkedListElem = hmlist#new<&u8, &u8>("k1", "jhelp"); */
    /* printf("here"); */
    /* (&q).hmlist_add<&u8, &u8>("k2", "aaaa"); */
    /* p: &&u8 = (&q).hmlist_get<&u8, &u8>(4); */
    /* printf(*p); */
    /* p: &&u8 = (&q).hmlist_get<&u8, &u8>("k1"); */
    /* printf(*p); */

    exit(0);
    0
};


// }}}
