// EXTERNS {{{
func malloc(bytes: u64) : &u8;
func realloc(data: &u8, bytes: u64) : &u8;
func strlen(str: &u8) : u64;
prefix free(data: &u8);
func strcpy(dest: &u8, src: &u8);
func strncpy(dest: &u8, src: &u8, len: u64);
func memcpy(dest: &u8, src: &u8, len: u64);
func strcmp(a: &u8, b: &u8) : u64;
func printf(str: &u8);
/* func printf(str: &u8, val: u64); */
/* func printf(str: &u8) = printf(str, 0); */
func putchar(char: u8);
func exit(code: u64);
func pow(base: u64, power: u64): u64;
func printint(i: u64);

// little extern thing to help me debug
// cuz i cant be asked to write it here
// func print_addr(addr: &u8);

// }}}

// SYSTEM {{{

#prec 25, builtin IntCmpEQ;
infix ==(a: u64, b: u64) : bool = @AS("int_cmp_eq a b");

#prec 25, builtin IntCmpNE;
infix !=(a: u64, b: u64) : bool = @AS("int_cmp_neq a b");

#prec 30, builtin IntCmpULT;
infix <(a: u64, b: u64) : bool = @AS("int_cmp_ult a b");

#prec 30, builtin IntCmpUGT;
infix >(a: u64, b: u64) : bool = @AS("int_cmp_ugt a b");

#prec 30, builtin IntCmpULE;
infix <=(a: u64, b: u64) : bool = @AS("int_cmp_ule a b");

#prec 30, builtin IntCmpUGE;
infix >=(a: u64, b: u64) : bool = @AS("int_cmp_uge a b");

#prec 20, builtin And;
infix &&(a: u64, b: u64) : u64 = @AS("int_and a b");

#prec 20, builtin Or;
infix ||(a: u64, b: u64) : u64 = @AS("int_or a b");

#prec 25, builtin IntCmpEQ;
infix ==(a: u8, b: u8) : bool = @AS("int_cmp_eq a b");

#prec 25, builtin IntCmpNEQ;
infix !=(a: u8, b: u8) : bool = @AS("int_cmp_neq a b");

#prec 30, builtin IntCm;
infix <(a: u8, b: u8) : bool = @AS("int_cmp_ult a b");

#prec 30;
infix >(a: u8, b: u8) : bool = @AS("int_cmp_ugt a b");

#prec 30;
infix <=(a: u8, b: u8) : bool = @AS("int_cmp_ule a b");

#prec 30;
infix >=(a: u8, b: u8) : bool = @AS("int_cmp_uge a b");

#prec 20;
infix &&(a: u8, b: u8) : u8 = @AS("int_and a b");

#prec 20;
infix ||(a: u8, b: u8) : u8 = @AS("int_or a b");

#prec 20;
infix &&(a: bool, b: bool) : bool = @AS("bool_and a b");

#prec 20;
infix ||(a: bool, b: bool) : bool = @AS("bool_or a b");

#prec 20;
infix %(a: u64, b: u64) : u64 = @AS("int_signed_mod a b");


#prec 10;
macro infix =(a: _, b: _) = @AS("store_in a b");

#prec 10;
macro infix [=](a: _, b: _) = @AS("raw_store_in a b");

prefix !(a: bool) : bool = @AS("bool_not a");

#prec 75;
infix +(a: u64, b: u64) : u64 = @AS("int_add a b");

#prec 75;
infix -(a: u64, b: u64) : u64 = @AS("int_sub a b");


#prec 75;
infix -(a: u8, b: u8) : u8 = @AS("int_sub a b");

#prec 100;
infix *(a: u64, b: u64) : u64 = @AS("int_mul a b");

macro suffix ++(a: _) : _ = {
    a = a + 1;
    a
};

macro suffix --(a: _) : _ = {
    a = a - 1;
    a
};

#prec 10;
macro infix +=(a: _, b: _) : _ = {
    a = a + b;
    a
};

/* prec 10; */
/* macro infix -=(a: _, b: _) : _ = { */
/*     a = a - b; */
/*     a */
/* }; */
/**/
/* prec 10; */
/* macro infix *=(a: _, b: _) : _ = { */
/*     a = a * b; */
/*     a */
/* }; */

// TODO: fix this ugly mess
#prec 120;
infix ^(a: u64, b: u64) : u64 = {
  if b == 0 { 1 }
  else {
    total: u64 = a;
    while (b - 1) > 0 {
      total = total * a;
      b = b - 1;
    };
    total
  }
};

func assert(val: bool, message: &u8) = if !val {
        printf("Assertion failed: ");
        printf(message);
        printf("\n");
        exit(1)
};

func assertVerbose(val: bool, message: &u8) = if val {
        printf("Assertion succeeded: ");
        printf(message);
        printf("\n");
    } else {
        printf("Assertion failed: ");
        printf(message);
        printf("\n");
        exit(1);
    };

overloadable func panic(message: &u8) = {
    printf("Panic!\n");
    printf(message);
    exit(1);
};

overloadable func panic() = {
    printf("Panic!\n");
    exit(1);
};

func debugPrint(message: &u8) = {
    printf(message);    
};


<T> func flatCopy(val: T) : &T = {
    data: &T = malloc(@sizeof(T)) as &T;
    memcpy(data as &u8, (&val) as &u8, @sizeof(T));

    data
};
// }}}


// STRING {{{

brackets [ ](str: &u8, index: u64) : &u8 = @AS("single_gep str index");

#prec 15;
infix ==(a: &u8, b: &u8) : bool = strcmp(a, b) == 0;

#prec 15;
infix !=(a: &u8, b: &u8) : bool = strcmp(a, b) != 0;

prefix copy(str: &u8) : &u8 = {
    dupl: &u8;
    dupl = malloc(str.strlen() + 1);
    strcpy(dupl, str);

    // bad debug tiem
    /* printf("Copied `"); */
    /* printf(dupl); */
    /* printf("` to `"); */
    /* print_addr(dupl); */
    /* printf("`\n"); */
    dupl
};

/* func length(str: &u8) : u64 = strlen(str); */

func contains(str: &u8, char: u8) : bool = {
    // TODO: revert to old logic after signage is fixed
    length: u64 = str.strlen();
    index: u64 = 0;
    while index != length {
        if *(str[index]) == char {
            return true 
        };
        index++;
    };
    false
};

func isNumeric(char: u8) : bool = (char >= '0') && (char <= '9');

func isAlpha(char: u8) : bool = ((char >= 'A') && (char <= 'Z') || (char >= 'a') && (char <= 'z'));

func isAlphanumeric(char: u8) : bool = char.isNumeric() || char.isAlpha();

func isWhitespace(char: u8) : bool = " \t\n".contains(char);

func printRepeatedChar(char: u8, repeat: u64) = {
    while repeat != 0 {
        putchar(' ');
        repeat--;
    };
};

func printIndentation(indentation: u64) = {
    putchar('\n');
    printRepeatedChar(' ', indentation);
};

func cToI(a: u8) : u64 = {
    q: u8 = a - '0';
    @AS("int_z_extend q 64")
};


func aToI(a: &u8) : u64 = {
    len: u64 = a.strlen();
    len = len;
    i: u64 = 0;
    ret: u64 = 0;
    while len > 0 {
        tmp: u64 = cToI(*(a[len - 1]));
        j: u64 = 0;
        while j < i {
            tmp = tmp * 10;
            j++;
        };
        i++;
        len--;
        ret += tmp;
    };

    ret
};

// }}}


// HASHMAP {{{
<K, V> type HMLinkedListElem = {
    hash: u64,
    val: &V,
    has_next_elem: bool,
    next_elem: &u8,// <T>HMLinkedListElem, // or 0 if no next elem, forgive me for using nullptrs
};

<K, V> prefix drop(elem: & <K, V>HMLinkedListElem) = {
    free(elem.val);
    if (elem.next_elem) as u64 != 0 {
        drop(elem.next_elem);
    };
    free(elem as &u8);
};


<K, V> overloadable func hmlist_contains_internal(self: & <K, V> HMLinkedListElem, hash: u64) : bool = {
  current: &<K, V>HMLinkedListElem = self;
  while true {
    /* printf("checking\n"); */
    if (current.hash) == hash { return true }
    else if !(current.has_next_elem) { return false }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem)}
  };
  false
};
<K, V> overloadable func hmlist_contains(self: & <K, V> HMLinkedListElem, key: K) : bool = self.hmlist_contains_internal<K, V>(hash(key));

<K, V> overloadable func hmlist_get(self: & <K, V> HMLinkedListElem, key: K) : &V = {
  hash: u64 = hash(key);
  current: & <K, V>HMLinkedListElem = self;
  while true {
    /* printf("get checking\n"); */
    if (current.hash) == hash { return (current.val) }
    else if ! (current.has_next_elem) { panic("Getting an element that doesn't exist") }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem) }
  };
  self.val
};

<K, V> overloadable func hmlist_get_elem_internal(self: & <K, V> HMLinkedListElem, hash: u64) : & <K, V> HMLinkedListElem = {
  current: &<K, V>HMLinkedListElem = self;
  while true {
    /* printf("getelem checking\n"); */
    if (current.hash) == hash { return current }
    else if !(current.has_next_elem) { panic("Getting an element that doesn't exist") }
    else { current = ((current.next_elem) as &<K, V>HMLinkedListElem) }
  };
  self
};

<K, V> overloadable func hmlist_add(self: & <K, V> HMLinkedListElem, key: K, value: V) = {
  hash: u64 = hash(key);
  if self.hmlist_contains_internal<K, V>(hash) {
    elem: & <K, V>HMLinkedListElem = self.hmlist_get_elem_internal<K, V>(hash);
    // TODO: free((elem.val) as &u8);
    elem.val = (malloc(@sizeof(V)) as &V);
    memcpy((elem.val) as &u8, (&value) as &u8, @sizeof(V));
  } else {
    elem: <K, V>HMLinkedListElem;
    (&elem).hash = hash;
    (&elem).val = (malloc(@sizeof(V)) as &V);
    memcpy((&(elem).val) as &u8, (&value) as &u8, @sizeof(V));
    &(elem).has_next_elem = (self.has_next_elem);
    &(elem).next_elem = (self.next_elem);
    elem2: & <K, V>HMLinkedListElem = malloc(@sizeof(elem)) as & <K, V>HMLinkedListElem;
    memcpy(elem2 as &u8, (&elem) as &u8, @sizeof(elem));
    (self.next_elem) = elem2 as &u8;
    (self.has_next_elem) = true;
  }
};

<K, V> func hmlist#new(key: K, value: V): <K, V> HMLinkedListElem = {
  elem: <K, V>HMLinkedListElem;
  &(elem).hash = hash(key);
  &(elem).val = (malloc(@sizeof(V)) as &V);
  memcpy((&(elem).val) as &u8, (&value) as &u8, @sizeof(V));
  &(elem).has_next_elem = false;
  elem
};


<K, V> overloadable func add(self: & <K, V>HMBucket, value: V, hash: u64) = {
  if self.is_using_linked_list {
    hnelem: bool = true;
    elem: <K, V> HMLinkedListElem = *(self.sub_values);
    while hnelem {
      if *(elem.hash) == hash {
        elem.val = value;
      };
      hnelem = *(elem.has_next_elem);
      elem = *(elem.next_elem);
    };
  };
};

<K, V> type HashMap = {
    has_init: bool,
    value: &<K, V> HMLinkedListElem,
};

<K,V> func hashmap#new() : <K, V> HashMap = {
    h: <K, V>HashMap;
    (&h).has_init = false;
    h
};

<K, V> overloadable func add(self: &<K, V>HashMap, key: K, value: V) = {
    if self.has_init {
      (self.value).add<K, V>(value, hash(key));
    } else {
      self.value = hmlist#new<K, V>(key, value);
      self.has_init = true;
    }
};

<K, V> overloadable func contains(self: &<K, V>HashMap, key: K) : bool = {
    if !(self.has_init) {false}
    else {
      (self.value).hmlist_contains<K, V>(key)
    }
};

<K, V> overloadable func get(self: &<K, V>HashMap, key: K) : &V = {
    if !(self.has_init) {panic("Getting an uninit HashMap"); v: V; &v}
    else {
        (self.value).hmlist_get<K, V>(key)
    }
};

/*
<T> type HashMap = {
    buckets: &&HMBucket,
};

<T> prefix drop(elem: & <T> HMBucket) = {
    if elem.does_contain_sub_buckets {
        i: u8 = 0_8;
        while i != 16 {
          //  drop<T> elem.sub_buckets[i];
        };
    } else {
        // drop<T> elem.sub_values;
    };
    free(elem as &u8);
}; */
// }}}

// HASHINGS {{{
overloadable func hash(h: u64): u64 = h;
overloadable func hash(h: &u8): u64 = {
  i: u64 = 0;
  total: u64 = 0;
  while ((*h[i])) != 0_8 {
    q: u8 = *h[i];
    /* putchar(q); */
    /* putchar(':'); */
    /* printint(2^2); */
    p: u64 = @AS("int_z_extend q 64");
    total += (53^i) * p;
    i += 1;
  };
  total = (total % 1000000009);
  /* printf("Hash of "); */
  /* printf(h); */
  /* printint(total); */
  total
};
// }}}


// LIST {{{

<T> type VariableArray = {
    len: u64,
    set_size: u64,
    data: &T
};

/* <T> func shallow_copy(va: <T> VariableArray) : & <T> VariableArray = { */
/*     new: & <T> VariableArray = malloc(@sizeof(<T> VariableArray)); */
/*     memcpy(new as &u8, (&va) as &u8, @sizeof(<T> VariableArray)); */

/*     new */
/* }; */

<T> func variablearray#new() : <T> VariableArray = {
    va: <T> VariableArray;
    
    (&va).data = malloc(@sizeof(T) * 64) as &T;
    (&va).len = 0;
    (&va).set_size = @sizeof(T) * 64;

    va
};

<T> func get(va: & <T> VariableArray, index: u64) : &T = {
    data: &T = va.data;
    @AS("single_gep data index") as &T
};

// brackets [ ] (va: &<T> VariableArray, i: u64) : &T = va.get<T

<T> func set(va: & <T> VariableArray, index: u64, val: T) = {
    memcpy(((va.get<T>(index)) as &u8), (&val) as &u8, @sizeof(T));
};

<T> func append(va: & <T> VariableArray, val: T) = {
    va.len += 1;
    if (va.len * @sizeof(T)) > va.set_size {
        va.set_size += (@sizeof(T) * 64);
        va.data = (realloc((va.data) as &u8, va.set_size) as &T);
    };
    /* (*(va.get<T>(va.len - 1))) = val; */
    va.set<T>(va.len - 1, val);
};

<T> prefix drop(va: <T> VariableArray) = {

    free((&va).data);
};

<T> func va_contains(va: & <T> VariableArray, val: T) : bool = {
    i: u64 = 0;
    while i < va.len {
        if *(va.get<T>(i)) == val {
            return true;
        };
        i++;
    };
    false
};


<T> func va_indexof(va: & <T> VariableArray, val: T) : u64 = {
    i: u64 = 0;
    while i < va.len {
        if *(va.get<T>(i)) == val {
            return i;
        };
        i++;
    };

    0
};

// }}}


// LEXER {{{

// type str = &u8;

type Lexer = {
    input: &u8,
    index: u64,
    input_len: u64,
};

// input is not copied
func lexer#new(input: &u8) : Lexer = {
    lexer: Lexer;
    (&lexer).index = 0;
    (&lexer).input = input;
    (&lexer).input_len = (&lexer).input.strlen();
    lexer
};

func peek(lexer: &Lexer) : Lexer = {
    dupl: Lexer;
    &dupl.input = lexer.input;
    &dupl.index = lexer.index;
    (&dupl).input_len = lexer.input_len;
    dupl
};

func peekChar(lexer: &Lexer) : u8 = {
    if lexer.index >= lexer.input_len {
        return '\0';    
    };
    *((lexer.input)[lexer.index])
};

func takeChar(lexer: &Lexer) : u8 = {
    a: u8 = lexer.peekChar();
    lexer.index = lexer.index + 1;
    a
};

func isEof(lexer: &Lexer) : bool = lexer.index >= lexer.input_len;

type LexString = {
    parent: &Lexer,
    offset: u64,
    len: u64
};

#prec 75;
infix + (a: LexString, b: LexString) : LexString = {
    result: LexString;
    (&result).offset = (&a).offset;
    (&result).len = (&b).len + (&b).offset - (&a).offset;
    (&result).parent = (&a).parent;

    result
};

func lexstring#new(parent: &Lexer, start: u64, end: u64) : LexString = {
    lexstring: LexString;
    (&lexstring).parent = parent;
    (&lexstring).offset = start;
    (&lexstring).len = (end - start);

    lexstring
};

// BIG TODO: implment lambdas for more monadic operation

// must remember to free!
// also, might segfault
// TODO: bounds-check logic
func render(lexstring: &LexString) : &u8 = {
    str: &u8;
    str = malloc(lexstring.len + 1);
    strncpy(str, (lexstring.parent.input)[lexstring.offset], lexstring.len);
    str[lexstring.len] [=] '\0';
    str
};

func debugLexString(val: &LexString, indentation: u64) = {
    str: &u8 = val.render();
    printIndentation(indentation);
    printf(str);
    free str;
};

func takeNumber(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    first_dot: bool = true;
    // TODO: this specific logic feels stupid. surely there's a better way?
    while lexer.peekChar().isNumeric() || ((lexer.peekChar() == '.') && first_dot) {
        (&string.len)++;
        if lexer.takeChar() == '.' first_dot = false;
    };
    string
};

func isConventionalId(char: u8, first: bool) : bool = char.isAlpha() || (char.isNumeric() && !first) || (char == '_') || (char == '@') || (char == '#');

func isSpecialId(char: u8) : bool = "+-><*/=%!&.|[]^".contains(char);
func isSingularId(char: u8) : bool = "()".contains(char);

func takeIdentifier(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    first: bool = true;
    while lexer.peekChar().isConventionalId(first) {
        /* printf("LTAKE\n"); */
        (&string.len)++;
        if first { first = false; };
        lexer.takeChar();
    };

    if &string.len == 0 {
        while lexer.peekChar().isSpecialId() {
          /* printf("LTAKES\n"); */
            (&string.len)++;
            lexer.takeChar();
        };
    };

    if &string.len == 0 {
        if lexer.peekChar().isSingularId() {
            (&string.len)++;
            lexer.takeChar();
        };
    };

    string
};

func takeOnlyWhitespace(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;
    
    while lexer.peekChar().isWhitespace() {
        (&string.len)++;
        lexer.takeChar();
    };

    string
};

func takeComment(lexer: &Lexer) : LexString = {
    string: LexString;
    &string.offset = lexer.index;
    &string.len = 0;
    &string.parent = lexer;

    if lexer.peekChar() == '/' {
        peeked_: Lexer = lexer.peek();
        peeked: &Lexer = &peeked_;
        peeked.takeChar();
        c: u8 = peeked.peekChar();
        if c == '/' {
            lexer.takeChar();
            lexer.takeChar();

            (&string.len) += 2;

            while lexer.takeChar() != '\n' {
                (&string.len)++;
            };
        } else if c == '*' {
            lexer.takeChar();
            lexer.takeChar();

            (&string.len) += 2;

            while true {
                if lexer.takeChar() == '*' {
                    if lexer.peekChar() == '/' {
                            lexer.takeChar();
                            (&string.len) += 2;
                            break;
                    };
                };
                (&string.len)++;
            };
        };
    };

    string
};

func takeWhitespace(lexer: &Lexer) : LexString = {
    string: LexString = lexer.takeOnlyWhitespace();
    while lexer.peekChar() == '/' {
        string += lexer.takeComment();
        string += lexer.takeOnlyWhitespace();
    };

    string
};

overloadable func require(lexer: &Lexer, char: u8) : LexString = {
    lexer.takeWhitespace();
    
    string: LexString;
    (&string).offset = lexer.index;
    (&string).parent = lexer;
    (&string.len) = 1;

    c: u8 = lexer.takeChar();

    if c != char {
        printf("Expected `");
        putchar(char);
        printf("` but got `");
        putchar(c);
        printf("`\n");
        panic("invalid character");
    };
    string
};

overloadable func require(lexer: &Lexer, str: &u8) : LexString = {
    lexer.takeWhitespace();
    
    string: LexString = lexer.takeIdentifier();

    if (&string).render() != str {
        printf("Expected str `");
        printf(str);
        printf("` but got `");
        printf((&string).render());
        printf("`\n");
        panic("invalid character");
    };
    string
};

// }}}

// PARSER {{{

type Parser = {
    lexer: &Lexer,
    // first then last then another set etc
    brackets: <u8> VariableArray,
    prefixes: <&u8> VariableArray,
    suffixes: <&u8> VariableArray,
    binaries: <&u8, u64> HMLinkedListElem,
};


// Type parsing {{{
enum TypeType = {
    Reference,
    Named,
    Struct,
    Func,
    Template,
};

type TypeExpr = {
    source: LexString,
    variant: TypeType,
    value: &u8,
};

type NamedTypeExpr = {
    name: LexString,
};

type TemplateTypeExpr = {
    types: <TypeExpr> VariableArray,
    value: TypeExpr,
};

// TODO: Default values
type StructVarDef = {
    name: LexString,
    type: TypeExpr,
};

type StructTypeExpr = {
    types: <StructVarDef> VariableArray,
};

func parseType(parser: &Parser) : TypeExpr;

func debugTypeExpr(ty: &TypeExpr, indentation: u64);

func debugStructVarDef(s: &StructVarDef, indentation: u64) = {
    printIndentation(indentation);
    debugLexString(&(s.name), indentation + 2);
    printIndentation(indentation);
    printf(":");
    debugTypeExpr(&(s.type), indentation + 2);
};
func debugStructTypeExpr(s: &StructTypeExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("STRUCT TYPE DEF:");
    i: u64 = 0;
    while i < (&(s.types)).len {
        debugStructVarDef((&(s.types)).get<StructVarDef>(i), indentation + 2);
        i++;
    };
};

func parseStructTypeExpr(parser: &Parser) : TypeExpr = {
    parser.lexer.takeWhitespace();
    start: u64 = parser.lexer.index;
    parser.lexer.require('{');
    parser.lexer.takeWhitespace();
    s_vardefs: <StructVarDef> VariableArray = variablearray#new<StructVarDef>();
    while !(parser.lexer.isEof()) && parser.lexer.peekChar() != '}' {
        name: LexString = parser.lexer.takeIdentifier();
        if (&name).len == 0 { panic("Expected a name for a struct vardef"); };
        parser.lexer.takeWhitespace();
        parser.lexer.require(':');
        parser.lexer.takeWhitespace();
        type: TypeExpr = parser.parseType();
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != '}' {
            parser.lexer.require(',');
        };
        parser.lexer.takeWhitespace();
        s: StructVarDef;
        (&s).name = name;
        (&s).type = type;
        (&s_vardefs).append<StructVarDef>(s);
    };
    parser.lexer.require('}');
    end: u64 = parser.lexer.index;
    s: StructTypeExpr;
    (&s).types = s_vardefs;
    
    t: TypeExpr;
    (&t).variant = TypeType#Struct;
    (&t).source = lexstring#new(parser.lexer, start, end);
    (&t).value = (s.flatCopy<StructTypeExpr>()) as &u8;

    t
};

func debugTemplateTypeExpr(ty: &TemplateTypeExpr, indentation: u64);

func debugTypeExprInternal(ty: &TypeExpr, indentation: u64) = {
  /* printIndentation(indentation); */
    if ty.variant == TypeType#Reference {
        printf("& ");
        debugTypeExprInternal((ty.value) as &TypeExpr, indentation);
    } else if ty.variant == TypeType#Named {
        nte: &NamedTypeExpr = (ty.value) as &NamedTypeExpr;
        rendered: &u8 = (&(nte.name)).render();
        printf(rendered);
        free rendered;
    } else if ty.variant == TypeType#Template {
        debugTemplateTypeExpr((ty.value) as &TemplateTypeExpr, indentation);
    } else if ty.variant == TypeType#Struct {
        debugStructTypeExpr((ty.value) as &StructTypeExpr, indentation);
    } else {
        printf("Dunno how to debug this type type")
    }
};

func debugTypeExpr(ty: &TypeExpr, indentation: u64) = {
    printIndentation(indentation);
    debugTypeExprInternal(ty, indentation);
};

func debugTemplateTypeExpr(ty: &TemplateTypeExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TEMPLATE:");
    i: u64 = 0;
    while i < (&(ty.types)).len {
        debugTypeExpr((&(ty.types)).get<TypeExpr>(i), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("UNDERLYING:");
    debugTypeExpr(&(ty.value), indentation + 2);
};

prefix copy(ty: TypeExpr) : &TypeExpr = ty.flatCopy<TypeExpr>();
prefix copy(ty: NamedTypeExpr) : &NamedTypeExpr = ty.flatCopy<NamedTypeExpr>();
prefix copy(ty: TemplateTypeExpr) : &TemplateTypeExpr = ty.flatCopy<TemplateTypeExpr>();


func parseTemplateList(parser: &Parser) : <TypeExpr> VariableArray = {
    parser.lexer.require('<');
    types: <TypeExpr> VariableArray = variablearray#new<TypeExpr>();
    parser.lexer.takeWhitespace();
    while (parser.lexer.peekChar() != '>') && !(parser.lexer.isEof()) {
      (&types).append<TypeExpr>(parser.parseType());
      parser.lexer.takeWhitespace();
      if parser.lexer.peekChar() != '>' {
        parser.lexer.require(',');
        parser.lexer.takeWhitespace();
      };
    };
    parser.lexer.require('>');
    parser.lexer.takeWhitespace();
    types
};

func parseType(parser: &Parser) : TypeExpr = {
  parser.lexer.takeWhitespace();
  c: u8 = parser.lexer.peekChar();
  if c == '&' {
    // ah its a uhh
    // pointer!
    parser.lexer.takeChar();
    parser.lexer.takeWhitespace();
    ty_: TypeExpr = parser.parseType();
    ty: &TypeExpr = copy ty_;
    res: TypeExpr;
    (&res).variant = TypeType#Reference;
    (&res).value = (ty as &u8);
    res
  } else if c == '<' {
    t: TemplateTypeExpr;
    (&t).types = parser.parseTemplateList();
    (&t).value = parser.parseType();
    ty: TypeExpr;
    (&ty).variant = TypeType#Template;
    (&ty).value = (copy t) as &u8;
    ty
  } else if c == '{' {
    t: TypeExpr = parser.parseStructTypeExpr();
    t
  } else {
    // TODO: structs, funcs
    name: LexString = parser.lexer.takeIdentifier();
    ty_: NamedTypeExpr;
    (&ty_).name = name;
    ty: &NamedTypeExpr = copy ty_;
    res: TypeExpr;
    (&res).variant = TypeType#Named;
    (&res).value = (ty as &u8);
    res
  }
};

// TODO: all the rest of the types; lambdas; templates

/* type StructTypeExpr { */
    /*  */
/* }; */
//  }}}

enum ExprType = {
    Number,
    Identifier,
    Block,
    String,
    If,
    While,
    Vardef,
    Return,
    Cast,
    CDef,
    PostfixBrackets,
    PrefixCall,
    SuffixCall,
    TemplatedExpr,
    Binary,
    Char
};

type Expr = {
    value: &u8, // something something data pointer
    variant: ExprType
};

type NumberExpr = {
    source: LexString,
    parsed: u64,
    bitwidth: LexString,
    has_bitwidth: bool,
};

type IdentifierExpr = {
    source: LexString,
    // TODO: namespaces
};
type VardefExpr = {
    source: LexString,
    ty: TypeExpr,
    var: IdentifierExpr,
};

func intoVardefExpr(e: &Expr) : &VardefExpr = {
    if e.variant != ExprType#Vardef {panic("Into-ed vardef, did not get it")};
    (e.value) as &VardefExpr
};

type BlockExpr = {
    source: LexString,
    exprs: <Expr> VariableArray,
    use_last_val: bool,
};

type StringExpr = {
    source: LexString,
    value: &u8,
};

type CharExpr = {
    source: LexString,
    value: u8,
};

type IfExpr = {
    source: LexString,
    cond: Expr,
    then: Expr,
    has_else: bool,
    else: Expr,
};

type WhileExpr = {
    source: LexString,
    cond: Expr,
    then: Expr,
};

type ReturnExpr = {
    source: LexString,
    has_val: bool,
    val: Expr,
};

type CastExpr = {
    source: LexString,
    val: Expr,
    ty: TypeExpr,
};

// TODO: make work with longer than 1-char brackets
type PostfixBracketsExpr = {
    source: LexString,
    val: Expr,
    brack_first: u8,
    brack_last: u8,
    args: <Expr> VariableArray,
};

type PrefixCallExpr = {
    source: LexString,
    val: Expr,
    prefix: IdentifierExpr,
};

type SuffixCallExpr = {
    source: LexString,
    val: Expr,
    suffix: IdentifierExpr,
};

type TemplatedExpr = {
    types: <TypeExpr> VariableArray,
    val: Expr,
};

type BinaryExpr = {
    lhs: Expr,
    rhs: Expr,
    op: IdentifierExpr,
};

// type CDefExpr


// lexer is moved
func parser#new(lexer: &Lexer) : Parser = {
    parser: Parser;
    (&parser).lexer = lexer;
    (&parser).brackets = variablearray#new<u8>();
    (&parser).prefixes = variablearray#new<&u8>();
    (&parser).suffixes = variablearray#new<&u8>();
    (&((&parser).brackets)).append<u8>('(');
    (&((&parser).brackets)).append<u8>(')');
    (&((&parser).prefixes)).append<&u8>("&");
    (&((&parser).prefixes)).append<&u8>("*");
    (&((&parser).prefixes)).append<&u8>("return");
    (&parser).binaries = hmlist#new<&u8, u64>("+", 50);
    (&((&parser).binaries)).hmlist_add<&u8, u64>(".", 1000);
    // TODO: THIS IS TESTING PLZ REMOVE
    // (&((&parser).prefixes)).append<&u8>("free");
    // (&((&parser).suffixes)).append<&u8>("_s");

    parser
};

overloadable func debugExprType(val: &ExprType, indentation: u64) = {
    printIndentation(indentation);
    if *val == ExprType#Number {
        printf("ExprType#Number");
    } else if *val == ExprType#Identifier {
        printf("ExprType#Identifier");
    } else if *val == ExprType#Block {
        printf("ExprType#Block");
    } else if *val == ExprType#String {
        printf("ExprType#String");
    } else if *val == ExprType#If {
        printf("ExprType#If");
    } else if *val == ExprType#While {
        printf("ExprType#While");
    } else if *val == ExprType#Vardef {
        printf("ExprType#Vardef");
    } else if *val == ExprType#Return {
        printf("ExprType#Return");
    } else if *val == ExprType#Cast {
        printf("ExprType#Cast");
    } else if *val == ExprType#PostfixBrackets {
        printf("ExprType#PostfixBrackets");
    } else if *val == ExprType#PrefixCall {
        printf("ExprType#PrefixCall");
    } else if *val == ExprType#SuffixCall {
        printf("ExprType#SuffixCall");
    } else if *val == ExprType#TemplatedExpr {
        printf("ExprType#TemplatedExpr");
    } else if *val == ExprType#Binary {
        printf("ExprType#Binary");
    } else if *val == ExprType#Char {
        printf("ExprType#Char");
    } else {
        printf("Debug expr type for this one not implmented yet");
    }
};


// forward-def
func parsePrimaryExpr(parser: &Parser) : Expr;
// GOT HERE, need to forward-def overloadbles
func debugBlockExpr(val: &BlockExpr, indentation: u64);
func debugIdentifierExpr(val: &IdentifierExpr, indentation: u64);
func debugVardefExpr(val: &VardefExpr, indentation: u64);
func debugNumberExpr(val: &NumberExpr, indentation: u64);
func debugStringExpr(val: &StringExpr, indentation: u64);
func debugIfExpr(val: &IfExpr, indentation: u64);
func debugWhileExpr(val: &WhileExpr, indentation: u64);
func debugReturnExpr(val: &ReturnExpr, indentation: u64);
func debugCastExpr(val: &CastExpr, indentation: u64);
func debugPostfixBracketsExpr(val: &PostfixBracketsExpr, indentation: u64);
func debugPrefixCallExpr(val: &PrefixCallExpr, indentation: u64);
func debugSuffixCallExpr(val: &SuffixCallExpr, indentation: u64);
func debugTemplatedExpr(t: &TemplatedExpr, indentation: u64);
func debugBinaryExpr(b: &BinaryExpr, indentation: u64);
func debugCharExpr(c: &CharExpr, indentation: u64);

overloadable func debugExpr(val: &Expr, indentation: u64) = {
    debugExprType(&(val.variant), indentation);
    if val.variant == ExprType#Block {
        debugBlockExpr((val.value) as &BlockExpr, indentation);
    } else if val.variant == ExprType#Identifier {
        debugIdentifierExpr((val.value) as &IdentifierExpr, indentation);
    } else if val.variant == ExprType#Number {
        debugNumberExpr((val.value) as &NumberExpr, indentation);
    } else if val.variant == ExprType#String {
        debugStringExpr((val.value) as &StringExpr, indentation);
    } else if val.variant == ExprType#If {
        debugIfExpr((val.value) as &IfExpr, indentation);
    } else if val.variant == ExprType#While {
        debugWhileExpr((val.value) as &WhileExpr, indentation);
    } else if val.variant == ExprType#Vardef {
        debugVardefExpr((val.value) as &VardefExpr, indentation);
    } else if val.variant == ExprType#Return {
        debugReturnExpr((val.value) as &ReturnExpr, indentation);
    } else if val.variant == ExprType#Cast {
        debugCastExpr((val.value) as &CastExpr, indentation);
    } else if val.variant == ExprType#PostfixBrackets {
        debugPostfixBracketsExpr((val.value) as &PostfixBracketsExpr, indentation);
    } else if val.variant == ExprType#PrefixCall {
        debugPrefixCallExpr((val.value) as &PrefixCallExpr, indentation);
    } else if val.variant == ExprType#SuffixCall {
        debugSuffixCallExpr((val.value) as &SuffixCallExpr, indentation);
    } else if val.variant == ExprType#TemplatedExpr {
        debugTemplatedExpr((val.value) as &TemplatedExpr, indentation);
    } else if val.variant == ExprType#Binary {
        debugBinaryExpr((val.value) as &BinaryExpr, indentation);
    } else {
        printf("Dunno how to debug this type");
    }
};

prefix drop(expr: Expr) = {
    free (&expr.value);
};

func parseExpr(parser: &Parser) : Expr;

func debugNumberExpr(val: &NumberExpr, indentation: u64) = {
    debugLexString(&(val.source), indentation);
    if val.has_bitwidth {
        printIndentation(indentation);
        printf("BW");
        debugLexString(&(val.bitwidth), indentation);
    };
};

func parseNumberExpr(parser: &Parser) : NumberExpr = {
    // debugPrint("Parsing number\n");
    number: LexString = parser.lexer.takeNumber();
    if &number.len == 0 {
        panic("Expected number");
    };
    bitwidth: LexString;
    has_bitwidth: bool = false;
    if parser.lexer.peekChar() == '_' {
        parser.lexer.takeChar();
        bitwidth = parser.lexer.takeNumber();
    };

    expr: NumberExpr;
    &expr.source = number;
    &expr.bitwidth = bitwidth;
    &expr.has_bitwidth = has_bitwidth;

    // TODO: atoi

    expr
};

prefix copy(val: NumberExpr) : &NumberExpr = {
    data: &NumberExpr = malloc(@sizeof(NumberExpr)) as &NumberExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(NumberExpr));

    data
};

overloadable func asExpr(number: NumberExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Number;

    // TODO: make it more silvery
    &expr.value = (copy number) as &u8;

    expr
};


func debugIdentifierExpr(val: &IdentifierExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("`");
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    printf("`");
    // debugLexString(&(val.source), indentation);
};

func parseIdentifierExpr(parser: &Parser) : IdentifierExpr = {
    // debugPrint("Parsing identifier expr\n");
    id: LexString = parser.lexer.takeIdentifier();
    if &id.len == 0 {
        panic("Expected valid identifier");
    };
    expr: IdentifierExpr;
    &expr.source = id;

    expr
};

prefix copy(val: IdentifierExpr) : &IdentifierExpr = {
    data: &IdentifierExpr = malloc(@sizeof(IdentifierExpr)) as &IdentifierExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(IdentifierExpr));

    data
};

overloadable func asExpr(id: IdentifierExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Identifier;

    &expr.value = (copy id) as &u8;

    expr
};

prefix copy (val: VardefExpr) : &VardefExpr = val.flatCopy<VardefExpr>();

func debugVardefExpr(val: &VardefExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("VARDEF `");
    id: &u8 = (&((&(val.var)).source)).render();
    printf(id);
    free id;
    printf("` DEFINED WITH TYPE");
    debugTypeExpr(&(val.ty), indentation + 2);
};

overloadable func asExpr(v: VardefExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Vardef;
    &expr.value = (copy v) as &u8;

    expr
};

func maybeVardefExpr(parser: &Parser, id: IdentifierExpr) : Expr = {
  parser.lexer.takeWhitespace();
  if parser.lexer.peekChar() == ':' {
    parser.lexer.takeChar();
    parser.lexer.takeWhitespace();
    ty_: TypeExpr = parser.parseType();
    ty: &TypeExpr = copy ty_;
    v_: VardefExpr;
    v: &VardefExpr = &v_;
    v.source = (&id.source) + ty.source;
    v.var = id;
    v.ty = ty_;
    v_.asExpr()
  } else { id.asExpr() }
};

func parseVardefExpr(parser: &Parser) : VardefExpr = {
    id: IdentifierExpr =  parser.parseIdentifierExpr();
    parser.lexer.takeWhitespace();
    if parser.lexer.peekChar() != ':' {panic("Expected ':'");};
    e: Expr = parser.maybeVardefExpr(id);
    if (&e).variant != ExprType#Vardef {panic("something is quite wrong")};
    *(((&e).value) as &VardefExpr)
};

func debugBlockExpr(val: &BlockExpr, indentation: u64) = {
    printIndentation(indentation);
    exprs: <Expr> VariableArray;
    exprs = val.exprs;

    printf("BLOCK: {");
    i: u64 = 0;
    while i < (&exprs).len {
        debugExpr(((&(val.exprs)).get<Expr>(i)), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("} using last value: ");
    printf(
        if val.use_last_val {
          "true"
        } else { "false" }
    );
};

func parseBlockExpr(parser: &Parser) : BlockExpr = {
    // debugPrint("Parsing block expr\n");
    parser.lexer.takeWhitespace();

    start: u64 = parser.lexer.index;
    
    parser.lexer.require('{');
    expr: BlockExpr;
    exprs: <Expr> VariableArray = variablearray#new<Expr>();

    last_semicolon: bool = true;

    while !(parser.lexer.isEof()) && (parser.lexer.peekChar() != '}') {
        internal_expr: Expr = parser.parseExpr();
        (&exprs).append<Expr>(internal_expr);
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() == '}' {
            last_semicolon = false;
            break;
        };
        // Don't require semicolons after blocks
        if &internal_expr.variant != ExprType#Block {
          parser.lexer.require(';')
        } else {
            if parser.lexer.peekChar() == ';' {
                parser.lexer.require(';');
            };
        };
        parser.lexer.takeWhitespace();
    };

    parser.lexer.require('}');
//    printf("len: ");
//    printint((&exprs).len);

    end: u64 = parser.lexer.index;

    (&expr).exprs = exprs;
    (&expr).source = lexstring#new(parser.lexer, start, end);
    (&expr).use_last_val = !last_semicolon;

    expr
};

prefix copy(val: BlockExpr) : &BlockExpr = {
    data: &BlockExpr = malloc(@sizeof(BlockExpr)) as &BlockExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(BlockExpr));

    data
};

overloadable func asExpr(id: BlockExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#Block;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugStringExpr(val: &StringExpr, indentation: u64) = {
    printIndentation(indentation);    
  /* printf("`"); */
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseStringExpr(parser: &Parser) : StringExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('"');

    str: <u8> VariableArray = variablearray#new<u8>();
    escaped: bool = false;
    while !(parser.lexer.isEof()) && (!((parser.lexer.peekChar() == '"') && (!(escaped)))) {
        next_char: u8 = parser.lexer.takeChar();
        if escaped {
            (&str).append<u8>(next_char);
            escaped = false;
        } else {
            if next_char == '\\' {
                escaped = true;
            } else {
                (&str).append<u8>(next_char);
            }
        }
    };

    parser.lexer.require('"');

    end: u64 = parser.lexer.index;
    s: StringExpr;
    (&s).source = lexstring#new(parser.lexer, start, end);
    (&s).value = (&str).data;

    s
};

prefix copy(val: StringExpr) : &StringExpr = {
    data: &StringExpr = malloc(@sizeof(StringExpr)) as &StringExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(StringExpr));

    data
};

overloadable func asExpr(id: StringExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#String;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugCharExpr(val: &CharExpr, indentation: u64) = {
    printIndentation(indentation);    
  /* printf("`"); */
    id: &u8 = (&(val.source)).render();
    printf(id);
    free id;
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseCharExpr(parser: &Parser) : CharExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('\'');

    char: u8 = parser.lexer.takeChar();
    if char == '\\' {
        char = parser.lexer.takeChar();
    };

    parser.lexer.require('\'');

    end: u64 = parser.lexer.index;
    s: CharExpr;
    (&s).source = lexstring#new(parser.lexer, start, end);
    (&s).value = char;

    s
};

prefix copy(val: CharExpr) : &CharExpr = {
    data: &CharExpr = malloc(@sizeof(CharExpr)) as &CharExpr;
    memcpy(data as &u8, (&val) as &u8, @sizeof(CharExpr));

    data
};

overloadable func asExpr(id: CharExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#Char;
    (&expr).value = (copy id) as &u8;

    expr
};



func debugIfExpr(val: &IfExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("IF: ");
    debugExpr(&(val.cond), indentation + 2);
    printIndentation(indentation);
    printf("THEN: ");
    debugExpr(&(val.then), indentation + 2);
    if (val.has_else) {
      printIndentation(indentation);
      printf("ELSE: ");
      debugExpr(&(val.else), indentation + 2);
    };
    /* printf("`"); */
    // debugLexString(&(val.source), indentation);
};

func parseIfExpr(parser: &Parser) : IfExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("if");
    
    cond: Expr = parseExpr(parser);
    then: Expr = parseExpr(parser);
    parser.lexer.takeWhitespace();

    else: Expr;
    peek_: Lexer = parser.lexer.peek();
    peeked: &Lexer = &peek_;
    n_id: LexString = peeked.takeIdentifier();
    next: &u8 = (&n_id).render();
    has_else: bool = if next == "else" {
        parser.lexer.takeIdentifier();
        else = parser.parseExpr();
        true
    } else false;

    free next;

    end: u64 = parser.lexer.index;
    i: IfExpr;
    (&i).source = lexstring#new(parser.lexer, start, end);
    (&i).cond = cond;
    (&i).then = then;
    (&i).else = else;
    (&i).has_else = has_else;

    i
};

prefix copy(val: IfExpr) : &IfExpr = flatCopy<IfExpr>(val);

overloadable func asExpr(id: IfExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#If;

    (&expr).value = (copy id) as &u8;

    expr
};

func debugWhileExpr(val: &WhileExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("WHILE: ");
    debugExpr(&(val.cond), indentation + 2);
    printIndentation(indentation);
    printf("DO: ");
    debugExpr(&(val.then), indentation + 2);
};

func parseWhileExpr(parser: &Parser) : WhileExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("while");
    
    cond: Expr = parseExpr(parser);
    then: Expr = parseExpr(parser);

    end: u64 = parser.lexer.index;
    w: WhileExpr;
    (&w).source = lexstring#new(parser.lexer, start, end);
    (&w).cond = cond;
    (&w).then = then;
    w
};

prefix copy(val: WhileExpr) : &WhileExpr = flatCopy<WhileExpr>(val);

overloadable func asExpr(id: WhileExpr) : Expr = {
  expr: Expr;
  (&expr).variant = ExprType#While;
  (&expr).value = (copy id) as &u8;

  expr
};

func debugReturnExpr(val: &ReturnExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("RETURN ");
    if val.has_val {
        printf("VAL");
        debugExpr(&(val.val), indentation + 2);
    } else {
        printf("NONE");
    };
};

func parseReturnExpr(parser: &Parser) : ReturnExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require("return");

    parser.lexer.takeWhitespace();
    c: u8 = parser.lexer.peekChar();
    has_val: bool = !((c == ';') || (c == '}'));

    val: Expr;

    if has_val {
        val = parser.parseExpr();
    };

    end: u64 = parser.lexer.index;

    r: ReturnExpr;
    (&r).has_val = has_val;
    (&r).val = val;
    (&r).source = lexstring#new(parser.lexer, start, end);
    r
};

prefix copy(val: ReturnExpr) : &ReturnExpr = flatCopy<ReturnExpr>(val);

overloadable func asExpr(id: ReturnExpr) : Expr = {
    expr: Expr;
    (&expr).variant = ExprType#Return;
    (&expr).value = (copy id) as &u8;

    expr
};

prefix copy (val: CastExpr) : &CastExpr = val.flatCopy<CastExpr>();

func debugCastExpr(val: &CastExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("CAST");
    (&(val.val)).debugExpr(indentation + 2);
    printIndentation(indentation);
    printf("TO");
    debugTypeExpr(&(val.ty), indentation + 2);
};

overloadable func asExpr(v: CastExpr) : Expr = {
    expr: Expr;
    &expr.variant = ExprType#Cast;
    &expr.value = (copy v) as &u8;

    expr
};

func maybeCastExpr(parser: &Parser, e: Expr) : Expr = {
  start: u64 = parser.lexer.index;
  parser.lexer.takeWhitespace();
  peeked: Lexer = parser.lexer.peek();
  next: &u8;
  ls: LexString = (&peeked).takeIdentifier();
  next = (&ls).render();
  ex: Expr = if next == "as" {
    parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    ty_: TypeExpr = parser.parseType();
    ty: &TypeExpr = copy ty_;
    v_: CastExpr;
    v: &CastExpr = &v_;
    v.source = lexstring#new(parser.lexer, start, parser.lexer.index);
    v.val = e;
    v.ty = ty_;
    v_.asExpr()
  } else { e };
  free next;
  ex
};

func debugPostfixBracketsExpr(val: &PostfixBracketsExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("POSTFIX BRACKETS:");
    printIndentation(indentation);
    putchar(val.brack_first);
    putchar(' ');
    putchar(val.brack_last);

    printIndentation(indentation);
    printf("UPON:");
    debugExpr(&(val.val), indentation + 2);
    printIndentation(indentation);
    printf("ARGS:");
    i: u64 = 0;
    while i < (&(val.args)).len {
        debugExpr((&(val.args)).get<Expr>(i), indentation + 2);
        i++;
    };
    
};

prefix copy(v: PostfixBracketsExpr) : &PostfixBracketsExpr = flatCopy<PostfixBracketsExpr>(v);

overloadable func asExpr(v: PostfixBracketsExpr) : Expr = {
    e: Expr;
    (&e).variant = ExprType#PostfixBrackets;
    (&e).value = (copy v) as &u8;

    e
};

func maybePostfixBracketsExpr(parser: &Parser, e: Expr) : Expr = {
    start: u64 = parser.lexer.index;
    /*
    parser.lexer.takeWhitespace();
    peeked: Lexer = parser.lexer.peek();
    ls: LexString = (&peeked).takeIdentifier();
    first: &u8 = (&ls).render();
    */
    first: u8 = parser.lexer.peekChar();
    if !((&(parser.brackets)).va_contains<u8>(first)) { return e; };
    idx: u64 = (&(parser.brackets)).va_indexof<u8>(first);
    if (idx % 2) != 0 {return e;};
    last: u8 = *((&(parser.brackets)).get<u8>(idx + 1));
    // skreeee
    // id_first: IdentifierExpr = parser.parseIdentifierExpr();
    parser.lexer.takeChar();
    parser.lexer.takeWhitespace();

    exprs: <Expr> VariableArray = variablearray#new<Expr>();

    while !(parser.lexer.isEof()) && !({
        parser.lexer.peekChar() == last
    }) {
        internal_expr: Expr = parser.parseExpr();
        (&exprs).append<Expr>(internal_expr);
        parser.lexer.takeWhitespace();
        if {
            parser.lexer.peekChar() == last
        } {
            break;
        };
        parser.lexer.require(',');

        parser.lexer.takeWhitespace();
    };

    parser.lexer.require(last);

    ex: PostfixBracketsExpr;
    (&ex).source = lexstring#new(parser.lexer, start, parser.lexer.index);
    (&ex).val = e;
    (&ex).brack_first = first;
    (&ex).brack_last = last;
    (&ex).args = exprs;


    ex.asExpr()
};

func debugPrefixCallExpr(p: &PrefixCallExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("PREFIX CALL:");
    debugIdentifierExpr(&(p.prefix), indentation + 2);
    printIndentation(indentation);
    printf("UPON");
    debugExpr(&(p.val), indentation + 2);
};

prefix copy(p: PrefixCallExpr) : &PrefixCallExpr = p.flatCopy<PrefixCallExpr>();

overloadable func asExpr(p: PrefixCallExpr) : Expr = {
    e: Expr;
    (&e).variant = ExprType#PrefixCall;
    (&e).value = (copy p) as &u8;
    e
};

func maybePrefixCallExpr(parser: &Parser, i: IdentifierExpr) : Expr = {
    r: &u8 = (&((&i).source)).render(); /*
    printf("Trying");
    printf(r);
    j: u64 = 0;
    while j < (&(parser.prefixes)).len {
        printf("\n ");
        printf(*((&(parser.prefixes)).get<&u8>(j)));
        j++;
    }; */
    if (&(parser.prefixes)).va_contains<&u8>(r) {
      // printf("PREFIXED");
      free r;
        p: PrefixCallExpr;
        (&p).prefix = i;
        (&p).val = parser.parsePrimaryExpr();
        end: u64 = parser.lexer.index;
        start: u64 = (&((&i).source)).offset;
        (&p).source = lexstring#new(parser.lexer, start, end);
        p.asExpr()
    } else {
      free r;
      i.asExpr()
    }
};

func debugSuffixCallExpr(p: &SuffixCallExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("SUFFIX CALL:");
    debugIdentifierExpr(&(p.suffix), indentation + 2);
    printIndentation(indentation);
    printf("UPON");
    debugExpr(&(p.val), indentation + 2);
};

// prefix copy(s: SuffixCallExpr) : &SuffixCallExpr = s.flatCopy<SuffixCallExpr>();
//prefix copy(s: SuffixCallExpr) : &SuffixCallExpr = flatCopy<SuffixCallExpr>(s);
// IDK why it no work as other one
prefix copy(s: SuffixCallExpr) : &SuffixCallExpr = {
  a: &SuffixCallExpr = flatCopy<SuffixCallExpr>(s);
  a
};
// prefix copy(s: )

// again IDK why
overloadable func sf_asExpr(p: SuffixCallExpr) : Expr = {
    e: Expr;
    (&e).variant = ExprType#SuffixCall;
    (&e).value = (copy p) as &u8;
    e
};

func maybeSuffixCallExpr(parser: &Parser, e: Expr) : Expr = {
    parser.lexer.takeWhitespace();
    l: Lexer = parser.lexer.peek();
    ls: LexString = (&l).takeIdentifier();
    sf: &u8 = (&ls).render();
    if (&(parser.suffixes)).va_contains<&u8>(sf) {
        free sf;
        start: u64 = parser.lexer.index;
        s: SuffixCallExpr;
        (&s).suffix = parser.parseIdentifierExpr();
        (&s).val = e;
        end: u64 = parser.lexer.index;
        (&s).source = lexstring#new(parser.lexer, start, end);
        s.sf_asExpr()
    } else {
      free sf;
      e
    }
};

prefix copy(t: TemplatedExpr) : &TemplatedExpr = t.flatCopy<TemplatedExpr>();

overloadable func asExpr(t: TemplatedExpr) : Expr = {
    ex: Expr;
    (&ex).variant = ExprType#TemplatedExpr;
    (&ex).value = (copy t) as &u8;
    ex
};

func debugTemplatedExpr(t: &TemplatedExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TEMPLATED EXPR:");
    i: u64 = 0;
    while i < (&(t.types)).len {
        debugTypeExpr((&(t.types)).get<TypeExpr>(i), indentation + 2);
        i++;
    };
    printIndentation(indentation);
    printf("UNDERLYING:");
    debugExpr(&(t.val), indentation + 2);
};

func maybeTemplatedExpr(parser: &Parser, e: Expr) : Expr = {
    // janks af. forgive me
    ls: LexString = lexstring#new(parser.lexer, parser.lexer.index - 1, parser.lexer.index);
    if (&ls).render() == " " {return e};
    if parser.lexer.peekChar() == '<' {
        types: <TypeExpr> VariableArray = parser.parseTemplateList();
        t: TemplatedExpr;
        (&t).types = types;
        (&t).val = e;
        t.asExpr()
    } else {e}
};

// DOES NOT HANDLE BINARY SHENANIGANS

func parsePrimaryExpr(parser: &Parser) : Expr = {
    parser.lexer.takeWhitespace();

    next_char: u8 = parser.lexer.peekChar();
    ex: Expr = if next_char.isNumeric() {
        parser.parseNumberExpr().asExpr()
    } else if next_char == '(' {
        parser.lexer.takeChar();
        e: Expr = parser.parseExpr();
        parser.lexer.takeWhitespace();
        parser.lexer.require(')');
        e
    } else if (next_char.isConventionalId(true) || next_char.isSpecialId()) {
        peeked_: Lexer = (parser.lexer.peek());
        peeked: &Lexer = &peeked_;
        nextTok: LexString = peeked.takeIdentifier();
        next: &u8 = (&nextTok).render();
        e: Expr = if next == "if" {parser.parseIfExpr().asExpr()}
        else if next == "while" {parser.parseWhileExpr().asExpr()}
        else if next == "return" {parser.parseReturnExpr().asExpr()}
        else {
          id: IdentifierExpr = parser.parseIdentifierExpr();
          v: Expr = parser.maybeVardefExpr(id);
          if (&v).variant == ExprType#Identifier {
            v = parser.maybePrefixCallExpr(id);
          };
          v
        };
        free next;
        e
    } else if next_char == '{' {
        ba: BlockExpr = parser.parseBlockExpr();
        e: Expr = ba.asExpr();
        e
    } else if next_char == '"' {
      parser.parseStringExpr().asExpr()
    } else if next_char == '\'' {
      parser.parseCharExpr().asExpr()
    } else {
        expr: Expr;
        printf("Cannot parse: `");
        putchar(next_char);
        printf("`\n");
        panic();

        expr
    };
    // TODO: fix this, maybe iterate until no changes?
    ex = parser.maybeTemplatedExpr(ex);
    ex = parser.maybePostfixBracketsExpr(ex);
    ex = parser.maybeSuffixCallExpr(ex);
    ex = parser.maybeCastExpr(ex);
    ex
};

prefix copy(b: BinaryExpr) : &BinaryExpr = b.flatCopy<BinaryExpr>();

func asExpr(b: BinaryExpr) : Expr = {
    ex: Expr;
    (&ex).variant = ExprType#Binary;
    (&ex).value = (copy b) as &u8;

    ex
};

func debugBinaryExpr(b: &BinaryExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("BINARY:");
    debugIdentifierExpr(&(b.op), indentation + 2);
    printIndentation(indentation);
    printf("LHS:");
    debugExpr(&(b.lhs), indentation + 2);
    printIndentation(indentation);
    printf("RHS:");
    debugExpr(&(b.rhs), indentation + 2);
};

func parseBinary(parser: &Parser, lhs_: Expr, current_prec: u64) : Expr = {
    lhs: Expr = lhs_;
    while true {
      parser.lexer.takeWhitespace();
      peekl: Lexer = parser.lexer.peek();
      id: LexString = (&peekl).takeIdentifier();
      peeked: &u8 = (&id).render();
      if !((&(parser.binaries)).hmlist_contains<&u8, u64>(peeked)) { free peeked; return lhs; };
      their_prec: u64 = *((&(parser.binaries)).hmlist_get<&u8, u64>(peeked));
      free peeked;
      if current_prec > their_prec { return lhs; };
      // okay take it
      op: IdentifierExpr = parser.parseIdentifierExpr();
      // and the rhs
      rhs: Expr = parser.parsePrimaryExpr();

      // identity theft
      our_prec: u64 = their_prec;

      parser.lexer.takeWhitespace();
      peekl = parser.lexer.peek();
      id = (&peekl).takeIdentifier();
      peeked = (&id).render();
    
      // TODO: negative numbers (!)
      their_prec = if !((&(parser.binaries)).hmlist_contains<&u8, u64>(peeked)) { 0 }
      else { *((&(parser.binaries)).hmlist_get<&u8, u64>(peeked)) };

      // if theirs is bigger than ours consider it first
      rhs = if their_prec > our_prec { parser.parseBinary(rhs, our_prec) }
      else { rhs };

      lhsnew: BinaryExpr;
      (&lhsnew).lhs = lhs;
      (&lhsnew).rhs = rhs;
      (&lhsnew).op = op;

      lhs = lhsnew.asExpr();
    };

    lhs
};

func parseExpr(parser: &Parser) : Expr = parser.parseBinary(parser.parsePrimaryExpr(), 0);

// }}}

// TL-PARSING {{{

// HINTS {{{
// TODO: use hashmap
type Hints = {
    source: LexString,
    names: <LexString> VariableArray,
    values: <Expr> VariableArray,
};

func debugHints(h: &Hints, indentation: u64) = {
    printIndentation(indentation);
    printf("HINTS:");
    // debugLexString(&(h.name), indentation);
    i: u64 = 0;
    while i < (&(h.values)).len {
        debugLexString((&(h.names)).get<LexString>(i), indentation + 2);
        debugExpr((&(h.values)).get<Expr>(i), indentation + 2);
        i++;
    };
};

func parseHints(parser: &Parser) : Hints = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('#');
    parser.lexer.takeWhitespace();
    names: <LexString> VariableArray = variablearray#new<LexString>();
    values: <Expr> VariableArray = variablearray#new<Expr>();
    while parser.lexer.peekChar() != ';' {
        name: LexString = parser.lexer.takeIdentifier();
        (&names).append<LexString>(name);
        parser.lexer.takeWhitespace();
        (&values).append<Expr>(parser.parseExpr());
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != ';' {parser.lexer.require(',');};
        parser.lexer.takeWhitespace();
    };
    end: u64 = parser.lexer.index;

    h: Hints;
    // (&h).name = name;
    (&h).values = values;
    (&h).names = names;
    (&h).source = lexstring#new(parser.lexer, start, end);
    h
};

// }}}
// TEMPLATES {{{

type TemplateExpr = {
    source: LexString,
    args: <LexString> VariableArray,
};

func parseTemplate(parser: &Parser) : TemplateExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('<');
    parser.lexer.takeWhitespace();
    v: <LexString> VariableArray = variablearray#new<LexString>();
    while parser.lexer.peekChar() != '>' {
        (&v).append<LexString>(parser.lexer.takeIdentifier());
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != '>' {
          parser.lexer.require(',');
          parser.lexer.takeWhitespace();
        };
    };
    parser.lexer.require('>');

    t: TemplateExpr;
    (&t).source = lexstring#new(parser.lexer, start, parser.lexer.index);
    (&t).args = v;

    t
};

func debugTemplateExpr(t: &TemplateExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TEMPLATE:");
    i: u64 = 0;
    while i < (&(t.args)).len {
        debugLexString((&(t.args)).get<LexString>(i), indentation + 2);
        i++
    };
};

// }}}

enum TLExprType = {
    CDef,
    Function,
    Typedef,
    Enum,
};

type TLExpr = {
    variant: TLExprType,
    hints: <Hints> VariableArray,
    value: &u8,
    template: TemplateExpr,
    has_template: bool,
};

type EnumTLExpr = {
    source: LexString,
    names: <IdentifierExpr> VariableArray,
    name: LexString,
};

prefix copy(e: EnumTLExpr) : &EnumTLExpr = e.flatCopy<EnumTLExpr>();
overloadable func asTLExpr(e: EnumTLExpr) : TLExpr = {
    t: TLExpr;
    (&t).variant = TLExprType#Enum;
    (&t).value = (copy e) as &u8;

    t
};

func debugEnumTLExpr(e: &EnumTLExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("ENUM:");
    debugLexString(&(e.name), indentation);
    i: u64 = 0;
    while i < (&(e.names)).len {
        debugIdentifierExpr((&(e.names)).get<IdentifierExpr>(i), indentation + 2);
        i++
    };
};

func parseEnumTLExpr(parser: &Parser) : EnumTLExpr = {
    start: u64 = parser.lexer.index;
    l: LexString = (parser.lexer.takeIdentifier());
    kwd: &u8 = (&l).render();
    if kwd != "enum" {
        panic("Expected `enum`");
    };
    parser.lexer.takeWhitespace();
    name: LexString = parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    parser.lexer.require('=');
    parser.lexer.takeWhitespace();
    parser.lexer.require('{');
    parser.lexer.takeWhitespace();
    
    names: <IdentifierExpr> VariableArray = variablearray#new<IdentifierExpr>();

    while !(parser.lexer.isEof()) && parser.lexer.peekChar() != '}' {
          (&names).append<IdentifierExpr>(parser.parseIdentifierExpr());
          parser.lexer.takeWhitespace();
          if parser.lexer.peekChar() != '}' {
              parser.lexer.require(',');
              parser.lexer.takeWhitespace();
          };
    };

    parser.lexer.require('}');

    end: u64 = parser.lexer.index;

    e: EnumTLExpr;
    (&e).source = lexstring#new(parser.lexer, start, end);
    (&e).names = names;
    (&e).name = name;

    e
};

type TypedefTLExpr = {
    source: LexString,
    name: LexString,
    ty: TypeExpr,
};

prefix copy(t: TypedefTLExpr) : &TypedefTLExpr = t.flatCopy<TypedefTLExpr>();
overloadable func asTLExpr(t: TypedefTLExpr) : TLExpr = {
    e: TLExpr;
    (&e).variant = TLExprType#Typedef;
    (&e).value = (copy t) as &u8;

    e
};

func debugTypedefTLExpr(t: &TypedefTLExpr, indentation: u64) = {
    printf("\nTYPEDEF:");
    debugLexString(&(t.name), indentation);
    debugTypeExpr(&(t.ty), indentation);
};

func parseTypedefTLExpr(parser: &Parser) : TypedefTLExpr = {
    start: u64 = parser.lexer.index;
    l: LexString = (parser.lexer.takeIdentifier());
    kwd: &u8 = (&l).render();
    if kwd != "type" {
        printf("got ");printf(kwd);
        panic("Expected `type`");
    };
    parser.lexer.takeWhitespace();
    name: LexString = parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    parser.lexer.require('=');
    parser.lexer.takeWhitespace();
    t: TypeExpr = parser.parseType();

    end: u64 = parser.lexer.index;

    e: TypedefTLExpr;
    (&e).source = lexstring#new(parser.lexer, start, end);
    (&e).ty = t;
    (&e).name = name;

    e
};

enum FnProtoType = {
    Infix,
    Suffix,
    Prefix,
    Brackets,
    Normal
};

func debugFnProtoType(f: FnProtoType, indentation: u64) = {
    printIndentation(indentation);
    if f == FnProtoType#Infix {printf("FnProtoType#Infix");}
    else if f == FnProtoType#Suffix {printf("FnProtoType#Suffix");}
    else if f == FnProtoType#Prefix {printf("FnProtoType#Prefix");}
    else if f == FnProtoType#Brackets {printf("FnProtoType#Brackets");}
    else if f == FnProtoType#Normal {printf("FnProtoType#Normal");}
    else {printf("Don't know how to debug this FnProtoType");}
};

type FnProto = {
  source: LexString,
    variant: FnProtoType,
    first: LexString,
    last: LexString, // only for bracketed
  args: <VardefExpr> VariableArray,
  has_retty: bool,
  retty: TypeExpr,
  overloadable: bool,
  macro: bool,
};

func debugFnProto(p: &FnProto, indentation: u64) = {
    printIndentation(indentation);
    printf("PROTO");
    if p.overloadable {
        printIndentation(indentation);
        printf("OVERLOADABLE");
    };
    debugFnProtoType(p.variant, indentation);
    debugLexString(&(p.first), indentation);
    if p.variant == FnProtoType#Brackets {debugLexString(&(p.last), indentation);};
    if p.has_retty {debugTypeExpr(&(p.retty), indentation)};
    i: u64 = 0;
    while i < (&(p.args)).len {
        debugVardefExpr((&(p.args)).get<VardefExpr>(i), indentation + 2);
        i++;
    };
};

func parseFnProto(parser: &Parser) : FnProto = {
    start: u64 = parser.lexer.index;
    ty: LexString = parser.lexer.takeIdentifier();
    r: &u8 = (&ty).render();
    overloadable: bool = if r == "overloadable" {free r; parser.lexer.takeWhitespace();
      ty: LexString = parser.lexer.takeIdentifier();
      r = (&ty).render(); true}
    else {false};
    macro: bool = if r == "macro" {free r; parser.lexer.takeWhitespace();
      ty: LexString = parser.lexer.takeIdentifier();
      r = (&ty).render(); true}
    else {false};
    fnty: FnProtoType = if r == "infix" {FnProtoType#Infix}
    else if r == "suffix" {FnProtoType#Suffix}
    else if r == "prefix" {FnProtoType#Prefix}
    else if r == "brackets" {FnProtoType#Brackets}
    else if r == "func" {FnProtoType#Normal}
    else {printf("`"); printf(r); printf("`"); free r; panic("Unknown FnProtoType ");FnProtoType#Normal};
    free r;
    
    parser.lexer.takeWhitespace();
    first: LexString = parser.lexer.takeIdentifier();
    // TODO: sanity checks
    parser.lexer.takeWhitespace();
    last: LexString;
    if fnty == FnProtoType#Brackets {
        last = parser.lexer.takeIdentifier();
        parser.lexer.takeWhitespace();
    };
    parser.lexer.require('(');
    parser.lexer.takeWhitespace();

    args: <VardefExpr> VariableArray = variablearray#new<VardefExpr>();

    while parser.lexer.peekChar() != ')' {
        (&args).append<VardefExpr>(parser.parseVardefExpr());
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != ')' {
            parser.lexer.require(',');
            parser.lexer.takeWhitespace();
        };
    };

    parser.lexer.require(')');

    parser.lexer.takeWhitespace();
    has_retty: bool = false;
    retty: TypeExpr;
    if parser.lexer.peekChar() == ':' {
        has_retty = true;
        parser.lexer.require(':');
        parser.lexer.takeWhitespace();
        retty = parser.parseType();
    };

    fnpr: FnProto;
    (&fnpr).source = lexstring#new(parser.lexer, start, parser.lexer.index);
    (&fnpr).first = first;
    (&fnpr).last = last;
    (&fnpr).args = args;
    (&fnpr).variant = fnty;
    (&fnpr).has_retty = has_retty;
    (&fnpr).overloadable = overloadable;
    (&fnpr).retty = retty;
    (&fnpr).macro = macro;

    fnpr
};

type FnDefTLExpr = {
  proto: FnProto,
  has_body: bool,
  body: Expr,
};

prefix copy(f: FnDefTLExpr) : &FnDefTLExpr = flatCopy<FnDefTLExpr>(f);
overloadable func asTLExpr(f: FnDefTLExpr) : TLExpr = {
    t: TLExpr;
    (&t).variant = TLExprType#Function;
    (&t).value = (copy f) as &u8;

    t
};

func debugFnDefTLExpr(f: &FnDefTLExpr, indentation: u64) = {
  printIndentation(indentation);
  printf("FNDEF");
    (&(f.proto)).debugFnProto(indentation);
    if f.has_body {
        printIndentation(indentation);
        printf("BODY");
        debugExpr(&(f.body), indentation + 2);
    };
};

func parseFnDefTLExpr(parser: &Parser) : FnDefTLExpr = {
  proto: FnProto = parser.parseFnProto();
  parser.lexer.takeWhitespace();
  has_body: bool = false;
  body: Expr;
  if parser.lexer.peekChar() == '=' {
      parser.lexer.require('=');
      body = parser.parseExpr();
      has_body = true;
};
  
  f: FnDefTLExpr;
  (&f).proto = proto;
  (&f).has_body = has_body;
  (&f).body = body;

  f
};


// TL CDEFS {{{
type CDefTLExpr = {
    source: LexString,
    name: LexString,
    values: <Expr> VariableArray,
};

prefix copy(c: CDefTLExpr) : &CDefTLExpr = flatCopy<CDefTLExpr>(c);
overloadable func asTLExpr(c: CDefTLExpr) : TLExpr = {
    t: TLExpr;
    (&t).variant = TLExprType#CDef;
    (&t).value = (copy c) as &u8;

    t
};

func debugCDefTLExpr(h: &CDefTLExpr, indentation: u64) = {
    printIndentation(indentation);
    printf("TLCDef:");
    debugLexString(&(h.name), indentation);
    i: u64 = 0;
    while i < (&(h.values)).len {
        debugExpr((&(h.values)).get<Expr>(i), indentation + 2);
        i++;
    };
};

func parseCDefTLExpr(parser: &Parser) : CDefTLExpr = {
    start: u64 = parser.lexer.index;
    parser.lexer.require('@');
    parser.lexer.takeWhitespace();
    name: LexString = parser.lexer.takeIdentifier();
    parser.lexer.takeWhitespace();
    parser.lexer.require('(');
    parser.lexer.takeWhitespace();
    values: <Expr> VariableArray = variablearray#new<Expr>();
    while parser.lexer.peekChar() != ')' {
        (&values).append<Expr>(parser.parseExpr());
        parser.lexer.takeWhitespace();
        if parser.lexer.peekChar() != ')' {parser.lexer.require(',');};
    };
    parser.lexer.require(')');
    end: u64 = parser.lexer.index;

    h: CDefTLExpr;
    (&h).name = name;
    (&h).values = values;
    (&h).source = lexstring#new(parser.lexer, start, end);
    h
};

//  }}}

func debugTLExprType(t: TLExprType) = {
    if t == TLExprType#Enum {printf("TLExprType#Enum");}
    else if t == TLExprType#Typedef {printf("TLExprType#Typedef");}
    else if t == TLExprType#Function {printf("TLExprType#Function");}
    else if t == TLExprType#CDef {printf("TLExprType#CDef");}
    else (printf("I don't know how to debug this TLExprType"))
};

func debugTLExpr(t: &TLExpr) = {
    printf("\n");
    printf("Type: ");
    debugTLExprType(t.variant);
    i: u64 = 0;
    while i < (&(t.hints)).len {
        debugHints((&(t.hints)).get<Hints>(i), 0);
        i++
    };
    if t.has_template {
        debugTemplateExpr(&(t.template), 0);
    };
    if t.variant == TLExprType#Enum {
        debugEnumTLExpr((t.value) as &EnumTLExpr, 0);
    } else if t.variant == TLExprType#Typedef {
        debugTypedefTLExpr((t.value) as &TypedefTLExpr, 0);
    } else if t.variant == TLExprType#Function {
        debugFnDefTLExpr((t.value) as &FnDefTLExpr, 0);
    } else if t.variant == TLExprType#CDef {
        debugCDefTLExpr((t.value) as &CDefTLExpr, 0);
    } else {
        printf("Can't debug this TL expr type!");
    }
};

func parseTLExpr(parser: &Parser) : TLExpr = {
    // TODO: hints, cdefs, etc etc
    parser.lexer.takeWhitespace();
    hints: <Hints> VariableArray = variablearray#new<Hints>();
    while parser.lexer.peekChar() == '#' {
        h: Hints = parser.parseHints();
        (&hints).append<Hints>(h);
        // hints.append<Hints>(parser.parseHints());
        parser.lexer.require(';');
        parser.lexer.takeWhitespace();
    };
    has_template: bool = false;
    template: TemplateExpr;
    if parser.lexer.peekChar() == '<' {
        template = parser.parseTemplate();
        has_template = true;
        parser.lexer.takeWhitespace();
    };
    peeked: Lexer = parser.lexer.peek();
    ls: LexString = (&peeked).takeIdentifier();
    next: &u8 = (&ls).render();
    e: TLExpr = if parser.lexer.peekChar() == '@' {
        parser.parseCDefTLExpr().asTLExpr()
    } else if next == "enum" {
        parser.parseEnumTLExpr().asTLExpr()
    } else if next == "type" {
        parser.parseTypedefTLExpr().asTLExpr()
    } else {
        // NOTE: we don't free rend on purpose
        // since it's kept lol

        f: FnDefTLExpr = parser.parseFnDefTLExpr();
        if (&((&f).proto)).variant == FnProtoType#Brackets {
            ls: LexString = (&((&f).proto)).first;
            rend: &u8 = (&ls).render();
            (&(parser.brackets)).append<u8>(*(rend[0]));
            ls = (&((&f).proto)).last;
            rend = (&ls).render();
            (&(parser.brackets)).append<u8>(*(rend[0]));
        } else if (&((&f).proto)).variant == FnProtoType#Prefix {
            ls: LexString = (&((&f).proto)).first;
            rend: &u8 = (&ls).render();
            (&(parser.prefixes)).append<&u8>(rend);
        } else if (&((&f).proto)).variant == FnProtoType#Suffix {
            ls: LexString = (&((&f).proto)).first;
            rend: &u8 = (&ls).render();
            (&(parser.suffixes)).append<&u8>(rend);
        } else if (&((&f).proto)).variant == FnProtoType#Infix {
            found: bool = false;
            hint: &Expr;
            i: u64 = 0;
            while i < (&hints).len {
                hint_: &Hints = (&hints).get<Hints>(i);
                j: u64 = 0;
                while j < (&(hint_.names)).len {
                  ls: &LexString = ((&(hint_.names)).get<LexString>(j));
                  rend: &u8 = (ls).render();
                  if rend == "prec" {
                      found = true;
                      hint = ((&(hint_.values)).get<Expr>(j));
                      break;
                  };
                  free rend;
                };
                if found {break};
                i++;
            };
            if !found {panic("Expected a prec hint for an infix fn");};
            // if (&(hint.values)).len != 1 {panic("Expected 1 arg to a prec hint");};
            arg: &Expr = hint; // (&(hint.values)).get<Expr>(0);
            if (arg.variant) != ExprType#Number {panic("Expected a number for a prec hint");};
            ls: LexString = ((arg.value) as &NumberExpr).source;
            rend: &u8 = (&ls).render();
            p: u64 = aToI(rend);
            free rend;
            ls = (&((&f).proto)).first;
            rend = (&ls).render();
            (&(parser.binaries)).hmlist_add<&u8, u64>(rend, p);
        };

        f.asTLExpr()
    };
    free next;
    (&e).hints = hints;
    (&e).has_template = has_template;
    (&e).template = template;
    
    parser.lexer.takeWhitespace();
    while (parser.lexer.peekChar() == ';') && (!(parser.lexer.isEof())){
        parser.lexer.takeChar();
        parser.lexer.takeWhitespace();
    };
    e
};

//  }}}


// {{{ COMPILER ISH

// INST DECL {{{
enum Instructions = {
  Call,
  Return,
  IfBranch,
  WhileBranch,
  Break,
  Vardef,
  Builtin,
};

// BUILTINS (ew) {{{
enum BuiltinInstructions = {
  Store,
  Load,
  IntCmpEQ,
  IntCmpNEQ,
  IntCmpULT,
  IntCmpUGT,
  IntCmpULE,
  IntCmpUGE,
  And,
  Or,
  Xor,
  Not,
  IntSignedRemainder,
  Add,
  Sub,
  Mul,
  IntDiv,
  ArrGEP,
};
// }}}

type Instruction = {
  variant: Instructions,
  value: &u8,
};
// }}}

// TYPES {{{
type CompilerType = {
  variant: TypeType,
  value: &u8,
};

type CompilerStructType = {
  names: <&u8> VariableArray,
  types: <CompilerType> VariableArray,
};
type CompilerTemplatedType = {
  types: <CompilerType> VariableArray,
  templated: CompilerType,
};
// }}}
type Block = {
  is_toplevel: bool,
  parent_instr_idx: u64,
  parent_block_idx: u64,
  parent_fn_idx: u64,
  instructions: <Instruction> VariableArray,
  idx: u64,
};
// BLOCK {{{
func block#newTl(parent_fn_idx: u64, idx: u64) : Block = {
  b: Block;
  (&b).is_tl = true;
  (&b).parent_fn_idx = parent_fn_idx;
  (&b).instructions = variablearray#new<Instruction>();
  (&b).idx = idx;

  b
};

func block#newParented(parent_fn_idx: u64, parent_instr_idx: u64, parent_block_idx: u64, idx: u64) : Block = {
  b: Block;
  (&b).is_tl = false;
  (&b).parent_fn_idx = parent_fn_idx;
  (&b).parent_instr_idx = parent_instr_idx;
  (&b).parent_block_idx = parent_block_idx;
  (&b).instructions = variablearray#new<Instruction>();
  (&b).idx = idx;

  b
};
// }}}

type FunctionArg = {
  name: &u8,
  ty: CompilerType,
};
type Function = {
    blocks: <Block> VariableArray,
    name: &u8,
    args: <FunctionArg> VariableArray,
    has_body: bool,
    idx: u64,
};

// FUNCTION {{{
func function#new(name: &u8, args: <FunctionArg> VariableArray, has_body: bool, idx: u64) : Function {
  f: Function;
  (&f).name = name;
  (&f).args = args;
  (&f).has_body = has_body;
  
  if has_body {
    (&f).blocks = variablearray#new<Block>();
    b: Block = block#newTl(idx, 0);
    (&(&f).blocks).append<Block>(b);
  };

  f
};
// }}}

type Module = {
  type_mappings: <&u8, CompilerType> HashMap,
  functions: <&u8, Function> HashMap,
};

// MODULE {{{

func module#new() : Module = {
  m: Module;
  (&m).type_mappings = hashmap#new<&u8, CompilerType>();
  (&m).functions = hashmap#new<&u8, Function>();
  m
};

// don't free name
func addFunc(self: &Module, name: &u8, args: <FunctionArg> VariableArray) : &Function {
  f: Function = function#new(name, args, )
};
// }}}

type Variable = {
    name: <u8> VariableArray,
    explicit: bool,
};



type CallInstruction = {
    target_fn: Variable,
    args: <Variable> VariableArray,
};

type ReturnInstruction = {
    has_val: bool,
    val: Variable,
};

type IfBranchInstruction = {
    condition: Variable,
    then: Block,
    has_else: bool,
    els: Block,
};

type WhileBranchInstruction = {
    condition: Variable,
    then: Block,
};

type VardefInstruction = {
  name: Variable,
  ty: CompilerType,
};

// }}}


// MAIN {{{

func readFile(name: &u8) : &u8;
func cinit();

func main() : u64 = {
    cinit();
    // code: &u8 = "overloadable brackets pqr rps(s: u648) : p65 = {a;};";
    code: &u8 = readFile("./silver.silver");
    lexer: &Lexer = &lexer#new(code);
    parser: &Parser = &parser#new(lexer);
    while !(parser.lexer.isEof()) {
      e: TLExpr = parser.parseTLExpr();
      debugTLExpr(&e);
    };
    exit(0);
    0
};


// }}}
